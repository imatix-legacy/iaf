<component
    name        = "scl_xmlstore"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B1"
    version     = "1.1"
    description = "Standard Component Library"
    object_name = "xmlstore">
<additional_source file = "uconsole.c" />
<!--
<additional_source file = "ggcode.c"/>
<additional_source file = "ggcomm.c"/>
<additional_source file = "ggeval.c"/>
<additional_source file = "ggfile.c"/>
<additional_source file = "ggfunc.c"/>
<additional_source file = "ggobjt.c"/>
<additional_source file = "ggpars.c"/>
<additional_source file = "ggstrn.c"/>
<additional_source file = "sflcons.c"/>
<additional_source file = "sflconv.c"/>
<additional_source file = "sflcvdp.c"/>
<additional_source file = "sflcvsb.c"/>
<additional_source file = "sflcvtp.c"/>
<additional_source file = "sfldate.c"/>
<additional_source file = "sfldir.c"/>
<additional_source file = "sflenv.c"/>
<additional_source file = "sflfile.c"/>
<additional_source file = "sflfind.c"/>
<additional_source file = "sflhttp.c"/>
<additional_source file = "sfllist.c"/>
<additional_source file = "sflmem.c"/>
<additional_source file = "sflnode.c"/>
<additional_source file = "sflstr.c"/>
<additional_source file = "sflsymb.c"/>
<additional_source file = "sfltok.c"/>
<additional_source file = "sfluhttp.c"/>
<additional_source file = "sflunic.c"/>
<additional_source file = "sflusymb.c"/>
<additional_source file = "sfluxml.c"/>
<additional_source file = "sfluxmll.c"/>
<additional_source file = "sflxml.c"/>
<additional_source file = "sflxmll.c"/>
-->
<object
    name       = "xmlstore"
    uuid       = "B97DF8B0-C99F-11D3-B3AF-00E09872C5B1"
    class_uuid = "B97DF8B1-C99F-11D3-B3AF-00E09872C5B1">
    <description>Component used to manipulate xml string and tree
    </description>
    <attribute name = "trace_mode" type = "bool"/>
    <attribute name = "data"       type = "UCODE"       reference = "yes" free = "yes"/>
    <attribute name = "root"       type = "UXML_ITEM"   reference = "yes" />
    <attribute name = "item"       type = "UXML_ITEM"   reference = "yes" />
    <attribute name = "attr"       type = "UXML_ATTR"   reference = "yes" />
    <attribute name = "valid"      type = "bool"/>
    <attribute name = "item_val"   type = "UCODE"       reference = "yes" free = "yes"/>
    <attribute name = "item_stack" type = "UXML_ITEM *" reference = "yes" free = "yes"/>
    <attribute name = "attr_stack" type = "UXML_ATTR *" reference = "yes" free = "yes"/>
    <attribute name = "ggcode_buf" type = "char"        reference = "yes" free = "yes" />
    <attribute name = "item_stack_nbr" type = "int"/>
    <attribute name = "attr_stack_nbr" type = "int"/>
    <attribute name = "error_str"      type = "UCODE"   reference = "yes" free = "yes" />
    <attribute name = "save_format"    type = "int"/>
    <attribute name = "thread_id"      type = "long"/>

    <method name = "alloc">
        <parameter type = "BSTR" name = "xml_string"/>
        <description>Alloc a XML tree from an XML string value.
        If parameter is NULL, allocate a root item.</description>
        <rule name = "alloc"/>
    </method>
    <method  name = "free">
        <description>Free all resources used by this object</description>
        <rule name = "free"/>
    </method>
    <method name = "load">
        <parameter type = "BSTR" name = "file_name"/>
        <description>Allocate an XML tree from a file</description>
        <rule name = "load"/>
    </method>
    <method name = "save">
        <parameter type = "BSTR"    name = "file_name"/>
        <parameter type = "VARIANT" name = "type" optional = "1"/>
        <description>
        Save the current xml tree to a file. the type parameter
        give xml type:
        Missing or 0 : ASCII
        1:             UTF8
        2:             UTF16
        </description>
        <rule name = "save"/>
    </method>
    <method name = "save_format">
        <parameter type = "long" name = "format"/>
        <description>
        Set the format when save, get value or get xmlstring
        value:
        0:  ASCII (default)
        1:  UTF8
        2:  UTF16
        </description>     
        <rule name = "save_format"/>
    </method>  
    <property name = "value">
        <return type = "BSTR" />
        <description>Return a string with current xml tree value</description>
        <rule name = "get_value"/>
        <sample>Set value = xml.value</sample>
    </property>
    <property name = "value">
        <parameter type = "BSTR" name = "newVal"/>
        <description>Set a new value for the xml tree</description>
        <rule name = "put_value"/>
        <sample>xml.value = "&lt;item1&gt;&lt;/item1&gt;"</sample>
    </property>
    <method name = "push_position">
        <description>Save in a stack current item and attribute position</description>
        <rule name = "push_position"/>
    </method>
    <method name = "pop_position">
        <description>Restore from stack Last saved item and attribute position</description>
        <rule name = "pop_position"/>
    </method>
    <property name = "item_name">
        <return type = "BSTR" />
        <description>Get item name</description>
        <rule name = "get_item_name"/>
        <sample>Set name = xml.item_name</sample>
    </property>
    <property name = "item_name">
        <parameter type = "BSTR" name = "newVal"/>
        <description>Set item name</description>
        <rule name = "put_item_name"/>
        <sample>xml.item_name = "item1"</sample>
    </property>
    <method name = "item_new">
        <parameter type = "BSTR"    name = "name"/>
        <parameter type = "VARIANT" name = "value" optional="1"/>
        <description>Create a new item as a child of the current item.
                     The new item is put at the end of the list of children item
                     for the current item. Current item position is not affected.</description>
        <rule name = "item_new"/>
    </method>
    <method name = "item_insert">
        <parameter type = "BSTR"    name = "name"/>
        <parameter type = "VARIANT" name = "value" optional="1"/>
        <description>Create a sibling item after the current item</description>
        <rule name = "item_insert"/>
    </method>
    <method name = "item_delete">
        <description>Delete current item. The new current item is the next sibling item
                     If current is the last item, the current item is the parent item</description>
        <rule name = "item_delete"/>
    </method>
    <property name = "item">
        <parameter type = "VARIANT" name = "name"        optional="1"/>
        <parameter type = "VARIANT" name = "default_val" optional="1"/>
        <return type = "VARIANT" />
        <description>Get item value (current without 'name' parameter)</description>
        <rule name = "get_item"/>
        <sample>Set item_val = xml.item</sample>
    </property>
    <property name = "item">
        <parameter type = "VARIANT" name = "name"        optional="1"/>
        <parameter type = "VARIANT" name = "default_val" optional="1"/>
        <parameter type = "VARIANT" name = "newVal"/>
        <description>Set a item value (current without 'name' parameter)</description>
        <rule name = "put_item"/>
        <sample>xml.item = "this is the value"</sample>
    </property>
    <property name = "item_search">
        <parameter type = "BSTR" name = "name"/>
        <parameter type = "BSTR" name = "key_name"/>
        <parameter type = "BSTR" name = "key_value"/>
        <parameter type = "BSTR" name = "attr_name"/>
        <return type = "BSTR" />
        <description>search the value of "attr_name" attribute
        for item name "name" for attribute "key_name" equal "key_value".
        Return NULL if not found. </description>
        <rule name = "get_item_search"/>
        <sample>To search the value of 'label' for item 'field'
                for attribute 'type' equal 'textual'

                Set label = xml.item_search ("field", "type", "textual", "label")
        </sample>
    </property>
    <property name = "item_child_value">
        <parameter type = "BSTR" name = "name"/>
        <parameter type = "VARIANT" name = "default_val" optional="1"/>
        <return    type = "VARIANT" />
        <description>Get value of child item with name 'name'</description>
        <rule name = "get_item_child_value"/>
        <sample>Set value = xml.item_child_value ("client")</sample>
    </property>
    <method name = "item_root">
        <description>Set current item to root item</description>
        <rule name = "item_root"/>
    </method>
    <method name = "item_first_child">
        <description>Set current item to first child item</description>
        <rule name = "item_first_child"/>
    </method>
    <method name = "item_last_child">
        <description>Set current item to last child item</description>
        <rule name = "item_last_child"/>
    </method>
    <method name = "item_set_current">
        <parameter type = "BSTR" name = "name"/>
        <description>Set current item to child item with name as specified</description>
        <rule name = "item_set_current"/>
    </method>
    <method name = "item_next">
        <description>Set current item to next sibling item.</description>
        <rule name = "item_next"/>
    </method>
    <method name = "item_prev">
        <description>Set current item to previous sibling item</description>
        <rule name = "item_prev"/>
    </method>
    <method name = "item_parent">
        <description>Set current item to parent item.</description>
        <rule name = "item_parent"/>
    </method>
    <property name = "attr">
        <parameter type = "VARIANT" name = "name" optional="1"/>
        <parameter type = "VARIANT" name = "default_val" optional="1"/>
        <return type = "VARIANT" />
        <description>Get value of attribute (current without parameter 'name')</description>
        <rule name = "get_attr"/>
        <sample>set value = xml.attr</sample>
    </property>
    <property name = "attr">
        <parameter type = "VARIANT" name = "name" optional="1"/>
        <parameter type = "VARIANT" name = "default_val" optional="1"/>
        <parameter type = "VARIANT" name = "newVal"/>
        <description>Set attribute value (current without parameter 'name')</description>
        <rule name = "put_attr"/>
        <sample>xml.attr = "new_value"</sample>
    </property>
    <property name = "attr_name">
        <return type = "BSTR" />
        <description>Get name of current attribute</description>
        <rule name = "get_attr_name"/>
        <sample>Set name = xml.attr_name</sample>
    </property>
    <property name = "valid">
        <return type = "BOOL" />
        <description>Indicates if last executed method was valid</description>
        <rule name = "get_valid"/>
        <sample>If xml.valid Then
                End If</sample>
    </property>
    <method name = "attr_delete">
        <parameter type = "VARIANT" name = "name" optional="1"/>
        <description>Delete attribute (current without parameter 'name')</description>
        <rule name = "attr_delete"/>
    </method>
    <method name = "attr_first">
        <description>Set object attribute pointer to first attribute of
                     current item</description>
        <rule name = "attr_first"/>
    </method>
    <method name = "attr_last">
        <description>Set object attribute pointer to last attribute of
                     current item</description>
        <rule name = "attr_last"/>
    </method>
    <method name = "attr_next">
        <description>Set object attribute pointer to next attribute of
                     current item</description>
        <rule name = "attr_next"/>
    </method>
    <method name = "attr_prev">
        <description>Set object attribute pointer to previous attribute of
                     current item</description>
        <rule name = "attr_prev"/>
    </method>

    <property name = "generate">
        <parameter type = "BSTR"    name = "output_dir" />
        <parameter type = "VARIANT" name = "script" optional="1"/>
        <return type = "BSTR"/>
        <description>Generate custom file, based on a GSL script.
        Use xml currently used. See GSLGEN documentation for
        complete description of GSL scripting language.
        The default output of generation is returned.</description>
        <!--rule name = "generate"/-->
        <rule name = "generate_unicode"/>
    </property>

    <method name = "set_trace">
        <parameter type = "BSTR" name = "file_name"/>
        <description>Set Trace mode on and append coprintf to 'file_name'</description>
        <rule name = "set_trace"/>
    </method>
    <property name = "xmlstring">
        <parameter type = "VARIANT" name = "item_name" optional="1"/>
        <parameter type = "VARIANT" name = "value"/>
        <description>Convert string into a xml tree and insert this in child list of
        current item. If parameter 'item_name' is specified, search child item with this name
        and insert xml tree in child list of this item.</description>
        <rule name = "put_item_tree"/>
    </property>
    <property name = "xmlstring">
        <parameter type = "VARIANT" name = "item_name" optional="1"/>
        <return type = "VARIANT"/>
        <description>Convert a xml tree into a string. If parameter 'item_name' is specified,
        search child item with this name and convert this item, else convert current item
        </description>
        <rule name = "get_item_tree"/>
    </property>
    <property name = "error">
        <return type = "BSTR"/>
        <description>Return the last error description</description>
        <rule name = "get_error"/>
    </property>
    <function name = "alloc_item_value">
        <parameter type = "UXML_ITEM *" name = "item"/>
        <description>Alloc a string and set value for a item value</description>
        <rule name = "alloc_item_value"/>
    </function>
    <function name = "alloc_root_item">
        <parameter type = "BSTR" name = "xml_string"/>
        <description>
        Alloc a XML tree from an XML string value.
        If parameter is NULL, allocate a root item.</description>
        <rule name = "alloc_root_item"/>
    </function>
<!---
    <function name = "format_datetime_value">
        <parameter type = "VARIANT" name = "value"/>
        <return    type = "char"/>
        <description>Format a date variant to a string value in format "yyyymmdd hhmmssmmm"</description>
        <rule name = "format_datetime_value"/>
    </function>
--->
<!--------------------------------------------------------------------------->
<!-- Rules implementation                                                  -->
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_root)
      {
        uxml_free (m_root);
        m_root = NULL;
      }
    m_item = NULL;
    m_attr = NULL;
    m_item_stack_nbr = 0;
    m_attr_stack_nbr = 0;

    if (m_trace_mode)
      {
        console_udisable ();
        console_ucapture (NULL, 'a');
        m_trace_mode = FALSE;
      }
    if (m_error_str)
      {
        mem_free (m_error_str);
        m_error_str = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
#include "uconsole.h"
#include "ggcode.h"                     /*  GSLgen functions                 */

/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2BSTR(var, str) {                                            \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = dest.bstrVal;                                              \
      }                                                                      \
}

#define VARIANT2LONG(var, str) {                                             \
    VARIANT dest;                                                            \
    str = 0L;                                                                \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \
            str = dest.lVal;                                                 \
      }                                                                      \
}

#define INIT_ERROR_STR if (m_error_str) mem_free (m_error_str); m_error_str = NULL;

#define GSL_BUFFER_SIZE 65000
/*  Append GSLgen output to our buffer                                       */

char **
    gg_code_output = NULL;
int
    gg_output_size = 0;


void
gslgen_stdout (const char *line)
{
    int
        buffer_size;                    /*  Total size of message text       */
    int
        length;

    if (line == NULL)
        return;

    if (gg_code_output == NULL)
        return;

    if (*gg_code_output == NULL)
      {
        *gg_code_output = (char *)mem_alloc (GSL_BUFFER_SIZE);
        **gg_code_output = '\0';
        buffer_size = 0;
        gg_output_size = GSL_BUFFER_SIZE;
      }

    length      = strlen (line);
    buffer_size = strlen (*gg_code_output);
    if (buffer_size + length &gt; gg_output_size)
      {
        gg_output_size += GSL_BUFFER_SIZE;
        *gg_code_output = (char *)mem_realloc (*gg_code_output, gg_output_size);
      }

    if (*gg_code_output == NULL)
        gg_output_size = 0;

    strcpy (&(*gg_code_output) [buffer_size], line);
}

char *
unicode2ascii (const unsigned short *string)
{
  char
      *feedback = NULL;
  UINT
      length;
  UINT
      codepage;

  if (string)
    {
      codepage = GetACP();
      length =( lstrlenW (string) + 1) * 2;
      feedback = (char *)mem_alloc (length);
      if (feedback)
          WideCharToMultiByte (codepage, 0, string, -1, feedback, length, NULL, NULL);

    }
  return (feedback);
}

static long
    global_thread_id = 1;

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "deactivate">
        <type  value = "activex_cpp">
    free ();
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "alloc">
        <type value = "activex_cpp">
    alloc_root_item (xml_string);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "alloc_root_item">
        <type value = "activex_cpp_data">
    UCODE
        *value;
    Bool
        free_value = TRUE;
    USES_CONVERSION;
        </type>
        <type value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;

    if (xml_string)
      {
        value = xml_string;
        free_value = false;
/*        value = unicode2ascii (xml_string);*/
        if ( value == NULL
        ||  *value == 0)
          {
            value = L"&lt;root/&gt;";
            free_value = false;
          }
      }
    else
      {
        value = L"&lt;root/&gt;";
        free_value = false;
      }

    if (m_trace_mode)
        couprintf (L"%6ld Xml store alloc_root_item: %s", m_thread_id, value);

    if (m_data)
      {
        mem_free (m_data);
        m_data = NULL;
      }
    if (m_root)
      {
        uxml_free (m_root);
        m_root = NULL;
      }
    if (m_item_stack)
      {
        mem_free (m_item_stack);
        m_item_stack = NULL;
      }
    if (m_attr_stack)
      {
        mem_free (m_attr_stack);
        m_attr_stack = NULL;
      }
    m_item = NULL;
    m_attr = NULL;
    m_item_stack_nbr = 0;
    m_attr_stack_nbr = 0;

    if (value)
        m_data = value;
    else
        m_data = L"&lt;root/&gt;";
    if (uxml_load_string (&m_root, m_data, FALSE) == 0)
      {
        m_item = uxml_first_child (m_root);
        if (m_item)
          {
            m_valid = TRUE;
            if (m_trace_mode)
                couprintf (L"    OK");
          }
      }
    m_data = NULL;
    if (value && free_value)
        mem_free (value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "push_position">
        <type value = "activex_cpp_data">
    UXML_ITEM
        **item_stack = NULL;
    UXML_ATTR
        **attr_stack  = NULL;
        </type>
        <type value = "activex_cpp">
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store push position (%d)", m_thread_id, m_item_stack_nbr);

    item_stack = (UXML_ITEM **)mem_alloc (sizeof (void *) * (m_item_stack_nbr + 1));
    if (item_stack)
      {
        if (m_item_stack_nbr > 0)
          {
            memcpy (&item_stack [1], (void *)m_item_stack, sizeof (UXML_ITEM *) * m_item_stack_nbr);
            mem_free (m_item_stack);
          }
        m_item_stack = item_stack;
      }
    if (m_item_stack)
      {
        *m_item_stack = m_item;
        m_item_stack_nbr++;
      }
    attr_stack = (UXML_ATTR **)mem_alloc (sizeof (void *) * (m_attr_stack_nbr + 1));
    if (attr_stack)
      {
        if (m_attr_stack_nbr > 0)
          {
            memcpy (&attr_stack [1], m_attr_stack, sizeof (UXML_ATTR *) * m_attr_stack_nbr);
            mem_free (m_attr_stack);
          }
        m_attr_stack = attr_stack;
      }
    if (m_attr_stack)
      {
        *m_attr_stack = m_attr;
        m_attr_stack_nbr++;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "pop_position">
        <type  value = "activex_cpp">
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store pop position (%d)", m_thread_id, m_item_stack_nbr);

    if (m_item_stack
    &&  m_item_stack_nbr > 0)
      {
        m_item = *m_item_stack;
        if (m_item_stack_nbr > 1)
            memcpy (m_item_stack, &m_item_stack [1], sizeof (UXML_ITEM *) * (m_item_stack_nbr - 1));
        else
          {
            mem_free (m_item_stack);
            m_item_stack = NULL;
          }
        m_item_stack_nbr--;
      }
    if (m_attr_stack
    &&  m_attr_stack_nbr > 0)
      {
        m_attr = *m_attr_stack;
        if (m_attr_stack_nbr > 1)
            memcpy (m_attr_stack, &m_attr_stack [1], sizeof (UXML_ATTR *) * (m_attr_stack_nbr - 1));
        else
          {
            mem_free (m_attr_stack);
            m_attr_stack = NULL;
          }
        m_attr_stack_nbr--;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "attr_delete">
        <type  value = "activex_cpp_data">
    UXML_ATTR
        *attr;
    BSTR
        s_name = NULL;
        </type>
        <type  value = "activex_cpp">
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store attr_delete", m_thread_id);

    VARIANT2BSTR (name, s_name);
    if (s_name)
      {
        if (m_item)
            m_attr = uxml_attr (m_item, s_name);
      }

    if (m_attr)
      {
        attr = uxml_next_attr (m_attr);
        uxml_free_attr (m_attr);
        m_attr = attr;
        if (m_trace_mode)
            couprintf (L"    OK");
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "alloc_item_value">
        <type  value = "activex_cpp">
    if (m_item_val)
        mem_free (m_item_val);
    m_item_val = NULL;

    if (item == NULL)
        return;

    m_item_val = uxml_item_child_value (item);
    /* If Item exist but have no value, return a empty string                */
    if (m_item_val == NULL)
        m_item_val = mem_ustrdup (L"");
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_item_tree">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item,
        *new_root = NULL,
        *cur_item = NULL,
        *new_item = NULL;
    BSTR
        s_item_name,
        s_value;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;
    INIT_ERROR_STR;

    VARIANT2BSTR (value,     s_value);
    VARIANT2BSTR (item_name, s_item_name);

    if (s_value == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (m_trace_mode)
        couprintf (L"%6ld xml strore put xmlstring %s", m_thread_id, s_value);

    if (s_item_name && *s_item_name != 0)
      {
        FORUCHILDREN (item, m_item)
          {
            if (wcscmp (uxml_item_name (item), s_item_name) == 0)
              {
                cur_item = item;
                break;
              }
          }
      }
    else
        cur_item = m_item;

    if (cur_item && *s_value != 0)
      {
         if (uxml_load_string (&new_root, s_value, TRUE) == 0)
           {
             /* Skip root item                                               */
             new_item = uxml_first_child (new_root);
             uxml_detach (new_item);
             uxml_free (new_root);
             if (new_item)
                 uxml_attach_child (cur_item, new_item);
             m_valid = TRUE;
             if (m_trace_mode)
                couprintf (L"    Ok inserted in %s", uxml_item_name (cur_item));
           }
         else
         if (m_trace_mode)
            couprintf (L"    Invalid xml value");
      }
    else
    if (m_trace_mode)
        couprintf (L"    Invalid item position");
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_item_tree">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *cur_item = NULL,
        *item     = NULL;
    UCODE
        *value    = NULL;
    BSTR
        s_item_name;
    char
        *utf_value;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;
    INIT_ERROR_STR;

    VARIANT2BSTR (item_name, s_item_name);

    if (m_trace_mode)
        couprintf (L"%6ld xml strore get xmlstring", m_thread_id);

    if (s_item_name && *s_item_name)
      {
        FORUCHILDREN (item, m_item)
          {
            if (wcscmp (uxml_item_name (item), s_item_name) == 0)
              {
                cur_item = item;
                break;
              }
          }
      }
    else
        cur_item = m_item;

    if (cur_item)
      {
        if (m_save_format == UNICODE_FORMAT_UTF8)
          {
            utf_value = uxml_save_utf8_string (cur_item);
            if (utf_value)
              {
                value = ascii2ucode (utf_value);
                mem_free (utf_value);
              }
          }
        else
            value = uxml_save_string (cur_item);
        if (value)
          {
            if (pVal)
              {
                 m_valid  = TRUE;
                 pVal-&gt; vt      = VT_BSTR;
                 pVal-&gt; bstrVal = SysAllocString (value);
                 if (m_trace_mode)
                     couprintf (L"    %s", value);
              }
            mem_free (value);
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "format_datetime_value">
        <type  value = "activex_cpp_data">
    SYSTEMTIME
        date;
        </type>
        <type  value = "activex_cpp">
    if (pVal != NULL
    &&  VariantTimeToSystemTime (value.date, &date))
      {
        /* Format Only time                                                  */
        if (date.wYear  == 1899
        &&  date.wMonth == 12
        &&  date.wDay   == 30)
          {
            if (date.wMilliseconds != 0)
                sprintf (pVal, "%02d:%02d:%02d.%03d",
                               date.wHour,
                               date.wMinute,
                               date.wSecond,
                               date.wMilliseconds);
            else
                sprintf (pVal, "%02d:%02d:%02d",
                               date.wHour,
                               date.wMinute,
                               date.wSecond);
          }
        /* Format only date                                                  */
        else if (date.wHour         == 0
        &&       date.wMinute       == 0
        &&       date.wSecond       == 0
        &&       date.wMilliseconds == 0)
          {
            sprintf (pVal, "%04d-%02d-%02d",
                           date.wYear,
                           date.wMonth,
                           date.wDay);
          }
        else
        if (date.wMilliseconds != 0)
            sprintf (pVal, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
                           date.wYear,
                           date.wMonth,
                           date.wDay,
                           date.wHour,
                           date.wMinute,
                           date.wSecond,
                           date.wMilliseconds);
        else
            sprintf (pVal, "%04d-%02d-%02d %02d:%02d:%02d",
                           date.wYear,
                           date.wMonth,
                           date.wDay,
                           date.wHour,
                           date.wMinute,
                           date.wSecond);
      }
    else
    if (pVal)
        *pVal = '\0';
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "attr_first" >
        <type  value = "activex_cpp" >
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_item)
      {
        m_attr = uxml_first_attr (m_item);
        if (m_attr)
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "attr_last" >
        <type  value = "activex_cpp" >
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_item)
      {
        m_attr = uxml_last_attr (m_item);
        if (m_attr)
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "attr_next" >
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_attr)
      {
        m_attr = uxml_next_attr (m_attr);
        if (m_attr)
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "attr_prev" >
        <type value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_attr)
      {
        m_attr = uxml_prev_attr (m_attr);
        if (m_attr)
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "free">
        <type  value = "activex_cpp">
    m_valid = TRUE;

    if (m_trace_mode)
        couprintf (L"%6ld  Xml store free", m_thread_id);

    if (m_data)
      {
        mem_free (m_data);
        m_data = NULL;
      }
    if (m_root)
      {
        uxml_free (m_root);
        m_root = NULL;
      }
    if (m_item_stack)
      {
        mem_free (m_item_stack);
        m_item_stack = NULL;
      }
    if (m_attr_stack)
      {
        mem_free (m_attr_stack);
        m_attr_stack = NULL;
      }
    mem_free (m_item_val);
    m_item_val = NULL;
    m_item     = NULL;
    m_attr     = NULL;
    m_item_stack_nbr = 0;
    m_attr_stack_nbr = 0;

    if (m_ggcode_buf)
      {
        mem_free (m_ggcode_buf);
        m_ggcode_buf = NULL;
        gg_output_size = 0;
      }

    if (m_trace_mode)
      {
        console_udisable ();
        console_ucapture (NULL, 'a');
        m_trace_mode = FALSE;
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_delete">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;

    if (m_trace_mode)
        couprintf (L"%6ld  Xml store item_delete", m_thread_id);

    if (m_item)
      {
        item = uxml_next_sibling (m_item);
        if (item == NULL)
          {
            if (m_trace_mode)
                couprintf (L"    move to parent");
            item = uxml_parent (m_item);
          }
        uxml_free (m_item);
        m_item = item;
        m_valid = TRUE;
        if (m_trace_mode)
            couprintf (L"    OK");
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_first_child" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item = NULL;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_item)
        item = uxml_first_child (m_item);
    while (item && !uxml_item_name (item))
        item = uxml_next_sibling (item);
    if (item)
      {
        m_item = item;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_insert">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item;
    BSTR
        val;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (name   == NULL
    ||  m_item == NULL)
        RETURN_AND_RELEASE (S_FALSE);


    VARIANT2BSTR (value, val);
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store item_insert: %s = %s", m_thread_id, name, val);

    item = uxml_create (name, NULL);
    if (item)
      {
        uxml_attach_sibling (m_item, item);
        if (val)
            item = uxml_new (item, NULL, val);
        m_valid = TRUE;
        if (m_trace_mode)
            couprintf (L"    OK");
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_last_child" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    item = uxml_last_child (m_item);
    while (item && !uxml_item_name (item))
        item = uxml_prev_sibling (item);
    if (item)
      {
        m_item = item;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_set_current" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;
    INIT_ERROR_STR;

    if (name == NULL)
        RETURN_AND_RELEASE (S_FALSE);
    if (m_item == NULL)
        RETURN_AND_RELEASE (S_OK);

    FORUCHILDREN (item, m_item)
      {
        if (wcscmp (uxml_item_name (item), name) == 0)
          {
            m_item = item;
            m_valid = TRUE;
            break;
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_new">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item;
    BSTR
        val;

        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;

    if (name == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    VARIANT2BSTR (value, val);

    if (m_trace_mode)
        couprintf (L"%6ld  Xml store item_new %s = %s", m_thread_id, name, val);
    if (m_item)
        item = uxml_new (m_item, name, NULL);
    if (item != NULL)
      {
        if (val && *val)
            item = uxml_new (item, NULL, val);
        if (item)
          {
            m_valid = TRUE;
            if (m_trace_mode)
                couprintf (L"    OK");
          }
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_next" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item = NULL;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_item)
        item = uxml_next_sibling (m_item);
    while (item && !uxml_item_name (item))
        item = uxml_next_sibling (item);

    if (item)
      {
        m_item = item;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_parent" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item = NULL;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_item)
        item = uxml_parent (m_item);
    if (item)
      {
        m_item = item;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_prev" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item = NULL;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_item)
        item = uxml_prev_sibling (m_item);
    while (item && !uxml_item_name (item))
        item = uxml_prev_sibling (item);
    if (item)
      {
        m_item = item;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "item_root" >
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    m_item  = NULL;
    if (m_root)
        m_item = uxml_first_child (m_root);
    if (m_item)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "load">
        <type value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type value = "activex_cpp">

    if (m_trace_mode)
        couprintf (L"%6ld  Xml store load %s", m_thread_id, file_name);

    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_data)
      {
        mem_free (m_data);
        m_data = NULL;
      }
    if (m_root)
      {
        uxml_free (m_root);
        m_root = NULL;
      }
    m_item = NULL;
    m_attr = NULL;
    if (uxml_load (&m_root, NULL, OLE2T (file_name)) == 0)
      {
        m_item = uxml_first_child (m_root);
        m_valid  = TRUE;
        if (m_trace_mode)
            couprintf (L"    OK");
      }
    else
        couprintf (L"    error: %s", uxml_error ());

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "save">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item;
    long
        save_type;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    VARIANT2LONG (type, save_type);
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (m_root)
      {
        item = uxml_first_child (m_root);
        if (item)
          {
            if (uxml_save_file (item, OLE2T(file_name), (byte)save_type) > 0)
            m_valid = TRUE;
          }
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "save_format">
        <type  value = "activex_cpp">
    m_save_format = (int)format;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "set_trace">
        <type  value = "activex_cpp_data">
    char
        *fname;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (file_name)
      {
        fname = OLE2T (file_name);
        if (fname)
          {
            console_uenable   ();
            console_uset_mode (CONSOLE_DATETIME);
            console_ucapture  (fname, 'a');
            m_trace_mode = TRUE;
            m_thread_id = global_thread_id++;
          }
       }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_attr" >
        <type  value = "activex_cpp_data">
    UCODE
        *value    = NULL;
    BSTR
        s_name;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    pVal-> vt = VT_NULL;

    VARIANT2BSTR (name, s_name);
    if (s_name)
      {
        if (m_item)
            value = uxml_get_attr (m_item, s_name, NULL);
      }
    else
    if (m_attr)
        value = uxml_attr_value (m_attr);

    if (value)
      {
        m_valid  = TRUE;
        pVal-&gt; vt      = VT_BSTR;
        pVal-&gt; bstrVal = SysAllocString (value);
      }
    else
    if (pVal-&gt; vt      == VT_NULL
    &&  default_val.vt != VT_NULL
    &&  default_val.vt != VT_ERROR)
        ::VariantChangeType (pVal, &default_val, 0, VT_BSTR);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_attr" >
        <type  value = "activex_cpp_data">
    UCODE
        *new_value = NULL,
        *attr_name = NULL;
    BSTR
        value,
        s_name;
        </type>
        <type  value = "activex_cpp">

    VARIANT2BSTR (name,   s_name);
    VARIANT2BSTR (newVal, value);
    m_valid  = FALSE;

    if (s_name == NULL && m_attr)
        s_name = uxml_attr_name (m_attr);

    if (s_name && m_item)
      {
        m_valid  = FALSE;
        uxml_put_attr (m_item, s_name, value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_attr_name" >
        <type  value = "activex_cpp_data">
    UCODE
        *value = NULL;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);
    if (m_attr)
        value = uxml_attr_name (m_attr);
    if (value)
        *pVal = SysAllocString (value);
    else
        *pVal = NULL;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_item" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *item = NULL;
    BSTR
        s_name;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    pVal-> vt = VT_NULL;

    if (m_item == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2BSTR (name, s_name);

    if (s_name)
      {
        FORUCHILDREN (item, m_item)
          {
            if (wcscmp (uxml_item_name (item), s_name) == 0)
                break;
          }
      }
    else
        item = m_item;

    if (item)
      {
        alloc_item_value (item);
        if (m_item_val)
          {
            m_valid = TRUE;
            pVal-> vt      = VT_BSTR;
            pVal-> bstrVal = SysAllocString (m_item_val);
            mem_free (m_item_val);
            m_item_val = NULL;
          }
      }
    if (pVal-> vt == VT_NULL
    &&  default_val.vt != VT_ERROR)
        ::VariantChangeType (pVal, &default_val, 0, VT_BSTR);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_item_child_value" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *child;
        </type>
        <type  value = "activex_cpp">
    m_valid   = FALSE;
    pVal-> vt = VT_NULL;

    if (name == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    if (m_item)
      {
        FORUCHILDREN (child, m_item)
          {
            if (wcscmp (uxml_item_name (child), name) == 0)
              {
                alloc_item_value (child);
                if (m_item_val)
                  {
                    m_valid        = TRUE;
                    pVal-> vt      = VT_BSTR;
                    pVal-> bstrVal = SysAllocString (m_item_val);
                    mem_free (m_item_val);
                    m_item_val = NULL;
                  }
                break;
              }
          }
      }
    if (pVal-> vt      == VT_NULL
    &&  default_val.vt != VT_ERROR
    &&  default_val.vt != VT_NULL)
        ::VariantChangeType (pVal, &default_val, 0, VT_BSTR);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_item" >
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *next,
        *item = NULL,
        *child;
    BSTR
        new_value,
        s_name;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    INIT_ERROR_STR;
    if (newVal.vt == VT_EMPTY
    ||  newVal.vt == VT_NULL
    ||  newVal.vt == VT_ERROR)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2BSTR (name,   s_name);
    VARIANT2BSTR (newVal, new_value);

    if (s_name)
      {
        FORUCHILDREN (item, m_item)
          {
            if (wcscmp (uxml_item_name (item), s_name) == 0)
                break;
          }
      }
    else
        item = m_item;

    if (item)
      {
        /* Remove old item values                                            */
        child = uxml_first_child (item);
        while (child)
          {
            next = uxml_next_sibling (child);
            if (!uxml_item_name (child))
                uxml_free (child);
            child = next;
          }
        if (uxml_new (item, NULL, new_value))
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_item_name" >
        <type  value = "activex_cpp">
    if (m_item)
        uxml_rename (m_item, newVal);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_item_name" >
        <type  value = "activex_cpp_data">
    UCODE
        *value;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (m_item)
      {
        value = uxml_item_name (m_item);
        if (value)
            *pVal = SysAllocString (value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_item_search">
        <type  value = "activex_cpp_data">
    UCODE
        *value = NULL;
    UXML_ITEM
        *child;
        </type>
        <type  value = "activex_cpp">
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store get_item_search", m_thread_id);

    if (m_item == NULL || pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    FORUCHILDREN (child, m_item)
      {
        if (wcscmp (uxml_item_name (child), name) == 0)
          {
            if (wcscmp (uxml_get_attr (child, key_name, L""), key_value))
              {
                value = uxml_get_attr (child, attr_name, L"");
                break;
              }
          }
      }
    if (value)
      {
        *pVal = SysAllocString (value);
        if (m_trace_mode)
            couprintf (L"   %s", value);
      }
    else
        *pVal = NULL;

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_valid"  >
        <type  value = "activex_cpp">
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store get valid %d", m_thread_id, m_valid);

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = m_valid;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_error"  >
        <type  value = "activex_cpp">
    if (m_trace_mode)
        couprintf (L"%6ld  Xml store get error", m_thread_id);

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);
    if (m_error_str == NULL)
      {
        if (*(uxml_error ()))
            m_error_str = mem_ustrdup (uxml_error ());
      }

    if (m_error_str)
      {
        *pVal = SysAllocString (m_error_str);
        INIT_ERROR_STR;
      }
    else
        *pVal = L"";
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_value" >
        <type  value = "activex_cpp">
    alloc_root_item (newVal);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_value" >
        <type  value = "activex_cpp_data">
    UCODE
        *value = NULL;
    char
        *utf_value;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    m_item = NULL;
    if (m_root)
        m_item = uxml_first_child (m_root);
    if (m_item)
      {
        if (m_save_format == UNICODE_FORMAT_UTF8)
          {
            utf_value = uxml_save_utf8_string (m_item);
            if (utf_value)
              {
                value = ascii2ucode (utf_value);
                mem_free (utf_value);
              }
          }
        else
            value = uxml_save_string (m_item);

      }
    if (value)
      {
        if (m_data)
            mem_free (m_data);
        m_data = value;
      }
    else
        value = L"";
    *pVal = SysAllocString (value);
    mem_free (m_data);
    m_data = NULL;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "generate">
        <type  value = "activex_cpp_data">
    XML_ITEM
        *item,
        *xml_switches;
    char
        *cur_dir,
        *str_outdir   = NULL,
        *str_template = NULL;
    int
        feedback;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (m_trace_mode)
        coprintf ("Xml store generate");

    m_valid = FALSE;
    INIT_ERROR_STR;
    *pVal   = NULL;

    cur_dir = get_curdir ();
    str_outdir = OLE2T (output_dir);

    if (m_trace_mode)
        coprintf ("  move current dir from %s to %s", cur_dir, str_outdir);

    set_curdir (str_outdir);

    VARIANT2STRING (script, str_template);
    xml_switches = xml_new (NULL, "switches", NULL);
    xml_put_attr (xml_switches, "shuffle",    "1");
    xml_put_attr (xml_switches, "ignorecase", "1");
    xml_put_attr (xml_switches, "template",   "1");
    xml_put_attr (xml_switches, "me",         "xmlstore");
    xml_put_attr (xml_switches, "date", conv_date_pict (date_now (), "yyyy/mm/dd"));
    xml_put_attr (xml_switches, "time", conv_time_pict (time_now (), "hh:mm:ss"));
    if (str_template != NULL)
        xml_put_attr (xml_switches, "script", str_template);

    /*  Send gslgen output to our own handler                                */
    gg_code_output = &m_ggcode_buf;
    gg_send_stdout (gslgen_stdout, FALSE);

    item = xml_first_child (m_root);
    feedback = gg_code (item, xml_switches);
    /*  And stop capturing output                                            */
    gg_send_stdout (NULL, FALSE);

    xml_free (xml_switches);

    set_curdir (cur_dir);
    mem_free (cur_dir);

    if (feedback == 0)
      {
        m_valid = TRUE;
        if (m_ggcode_buf)
            *pVal = T2BSTR (m_ggcode_buf);
        if (m_trace_mode)
            coprintf ("    OK");
      }
    else
    if (m_trace_mode)
        coprintf ("    Error");

    if (m_ggcode_buf)
      {
        mem_free (m_ggcode_buf);
        m_ggcode_buf = NULL;
        gg_output_size = 0;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "generate_unicode">
        <type  value = "activex_cpp_data">
    UXML_ITEM
        *uroot = NULL;
    XML_ITEM
        *root = NULL,
        *item,
        *xml_switches;
    char
        *str_value,
        *cur_dir,
        *str_outdir   = NULL,
        *str_template = NULL;
    int
        feedback;
    UCODE
        *p,
        *value;

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (m_trace_mode)
        coprintf (L"Xml store generate");

    m_valid = FALSE;
    INIT_ERROR_STR;

    *pVal   = NULL;

    if (m_root)      
        uroot = uxml_first_child (m_root);
    if (uroot)
        value = uxml_save_string (uroot);
    if (value)
      {
         str_value = ucode2ascii (value);
         mem_free (value);
         if (str_value)
           {
             if (xml_load_string (&root, str_value, FALSE) != 0)
               {
                 xml_free (root);
                 root = NULL;
               }
             mem_free (str_value);
           }
      }
    if (root)
      {
        cur_dir = get_curdir ();
        str_outdir = OLE2T (output_dir);

        if (m_trace_mode)
            coprintf (L"  move current dir from %s to %s", cur_dir, str_outdir);

        set_curdir (str_outdir);

        VARIANT2STRING (script, str_template);
        xml_switches = xml_new (NULL, "switches", NULL);
        xml_put_attr (xml_switches, "shuffle",    "1");
        xml_put_attr (xml_switches, "ignorecase", "1");
        xml_put_attr (xml_switches, "template",   "1");
        xml_put_attr (xml_switches, "me",         "xmlstore");
        xml_put_attr (xml_switches, "date", conv_date_pict (date_now (),
                                            "yyyy/mm/dd"));
        xml_put_attr (xml_switches, "time", conv_time_pict (time_now (),
                                            "hh:mm:ss"));
        if (str_template != NULL)
            xml_put_attr (xml_switches, "script", str_template);

        /*  Send gslgen output to our own handler                            */
        gg_code_output = &m_ggcode_buf;
        gg_send_stdout (gslgen_stdout, FALSE);


        item = xml_first_child (root);
        feedback = gg_code (item, xml_switches);
        /*  And stop capturing output                                        */
        gg_send_stdout (NULL, FALSE);

        xml_free (xml_switches);

        set_curdir (cur_dir);
        mem_free (cur_dir);

        if (feedback == 0)
          {
            m_valid = TRUE;
            if (m_ggcode_buf)
                *pVal = T2BSTR (m_ggcode_buf);
            if (m_trace_mode)
                coprintf (L"    OK");

            /* Reload xml from gg_code (maybe script have changed xml)       */
            str_value = xml_save_string (item);
            if (str_value)
              {
                value = ascii2ucode (str_value);
                mem_free (str_value);
                p = value;
                http_decode_umeta (value, &p, wcslen (value) +  1);
                uroot = NULL;
                if (uxml_load_string (&uroot, value, FALSE) != 0)
                  {
                    uxml_free (uroot);
                    uroot = NULL;
                  }
                else
                  {
                    if (m_data)
                      { 
                        mem_free (m_data);
                        m_data = NULL;
                      }
                    if (m_root)
                      {
                        uxml_free (m_root);
                        m_root = NULL;
                      }
                    if (m_item_stack)
                      {
                        mem_free (m_item_stack);
                        m_item_stack = NULL;
                      }
                    if (m_attr_stack)
                      {
                        mem_free (m_attr_stack);
                        m_attr_stack = NULL;
                      }
                    m_item = NULL;
                    m_attr = NULL;
                    m_item_stack_nbr = 0;
                    m_attr_stack_nbr = 0;
                    m_root = uroot;
                    m_item = uxml_first_child (m_root);
                 }
               mem_free (value);
             }
          }
        else
            if (m_trace_mode)
                coprintf (L"    Error");

        xml_free (root);

        if (m_ggcode_buf)
          {
            mem_free (m_ggcode_buf);
            m_ggcode_buf = NULL;
            gg_output_size = 0;
          }
      }
        </type>
    </rule>
</object>
<!--------------------------------------------------------------------------->
    <test>
&lt;%
 Set obj = Server.CreateObject ("scl.xmlstore")
 obj.alloc ("&lt;test&gt;&lt;line param=""1""&gt;value1&lt;/line&gt;&lt;line param=""2""&gt;value2&lt;/line&gt;&lt;/test&gt;")
 If obj.valid Then
%&gt;
&lt;PRE&gt;
&lt;%
    default_val = "invalid text"
    obj.item_first_child
	do while (obj.valid)
    %&gt;
    Item value = &lt;% =obj.item %&gt;
        Param     = &lt;% =obj.attr ("param")%&gt;
        def text  = &lt;% =obj.attr ("invalid", "text")%&gt;
        def var   = &lt;% =obj.attr ("invalid", default_val)%&gt;
        def num   = &lt;% =obj.attr ("invalid", 5)%&gt;
        def null  = &lt;% =obj.attr  ("invalid")%&gt;
        &lt;%

        set save = obj
        set obj = Server.CreateObject ("scl.xmlstore")
        save.item_next
        set obj = Nothing
        set obj = save

    Loop
    End If
	obj.free
' Check set attribute with different type
obj.alloc ("&lt;test /&gt;")
obj.item_new "item", Now ()
obj.item_first_child
obj.attr ("text") = "text"
obj.attr ("num")  = 10
obj.attr ("real") = 3.141592
obj.attr ("timestamp") = Now ()
obj.attr ("date") = Date ()
obj.attr ("time") = Time ()
obj.attr ("null_val") = NULL
obj.item_insert "other", Date ()
obj.item_root
obj.xmlstring = "&lt;included&gt;&lt;item1&gt;xxx&lt;/item1&gt;&lt;item2&gt;zzz&lt;/item2&gt;&lt;/included&gt;"
Response.Write chr(13) & Server.HTMLEncode (obj.value) & chr (13)

obj.save server.mappath (".") & "\test.xml"
obj.load server.mappath (".") & "\test.xml"
script_value = server.mappath (".") & "\test.gsl"
result = obj.generate (server.mappath ("."), script_value)
obj.free
    %&gt;
&lt;/PRE&gt;
    </test>

</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_security"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B2"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "security">
<additional_source file = "fcrypt.c" />
<!--------------------------------------------------------------------------->
<object
    name       = "security"
    uuid       = "86F19D81-F4D1-11D3-8509-0000B494E941"
    class_uuid = "86F19D82-F4D1-11D3-8509-0000B494E941">
    <description>Component for security consideration: hashing password, ...
    </description>
    <attribute name = "crypt_type"   type = "short"                    />
    <property name = "random_password">
        <parameter type = "VARIANT" name = "size" optional="1"/>
        <return type = "BSTR" />
        <description>Generate a random password. Default size is 6 characters</description>
        <rule name = "get_random_password"/>
    </property>
    <property name = "hash">
        <parameter type = "VARIANT" name = "password"/>
        <return type = "BSTR" />
        <description>Hash a password string</description>
        <rule name = "get_hash"/>
    </property>
    <property name = "temp_filename">
        <parameter type = "VARIANT" name = "directory" optional="1"/>
        <parameter type = "VARIANT" name = "extension" optional="1"/>
        <return type="BSTR" />
        <description>Get a temporary file name into a directory.
        If directory is no set, use the TEMP directory with 'tmp' extension.
        </description>
        <rule name = "get_temp_filename"/>
    </property>
    <method name="save_encrypt">
        <parameter type = "BSTR"    name = "source_file"     />
        <parameter type = "BSTR"    name = "target_file" />
        <parameter type = "VARIANT" name = "key"       />
        <parameter type = "VARIANT" name = "remove_source" optional="1" />
        <description>Get a source file and save this emcrypted to the target
        file. Use the paramter key to encrypt. If the parameter 'remove_source'
        is set to TRUE, the source file is deleted.
        Use full path name if possible.
        </description>
        <rule name = "save_encrypt"/>
    </method>
    <method name="save_decrypt">
        <parameter type = "BSTR"    name = "source_file"     />
        <parameter type = "BSTR"    name = "target_file" />
        <parameter type = "VARIANT" name = "key"       />
        <parameter type = "VARIANT" name = "remove_source" optional="1" />
        <description>Get a source file and save this decrypted to the target
        file. Use the paramter key to decrypt. If the parameter 'remove_source'
        is set to TRUE, the source file is deleted.
        Use full path name if possible.
        </description>
        <rule name = "save_decrypt"/>
    </method>
    <method name = "set_crypt_type">
        <parameter type = "VARIANT" name = "type" />
        <description>Set the algorythm to crypt and decrypt file.
        Supported algorythm is : DES, 3DES, IDEA, RC4
        Default algorythm is RC4
        </description>
        <rule name = "set_crypt"/>
    </method>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
#include "fcrypt.h"

/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}


/* Get a Boolean from a variant value                                       */
#define VARIANT2BOOL(var, str) {                                             \
    VARIANT dest;                                                            \
    str = FALSE;                                                             \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BOOL) == S_OK)           \
            str = (BOOL)dest.boolVal;                                        \
      }                                                                      \
}

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "constructor">
        <type  value = "activex_cpp">
    randomize ();
    m_crypt_type = CRYPT_TYPE_RC4;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "set_crypt" >
        <type  value = "activex_cpp_data">
    char
        *crypt_str;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    VARIANT2STRING (type, crypt_str);

    if (crypt_str == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (lexcmp (crypt_str, "DES") == 0)
        m_crypt_type = CRYPT_TYPE_DES;
    else
    if (lexcmp (crypt_str, "3DES") == 0)
        m_crypt_type = CRYPT_TYPE_3DES;
    else
    if (lexcmp (crypt_str, "IDEA") == 0)
        m_crypt_type = CRYPT_TYPE_IDEA;
    else
        m_crypt_type = CRYPT_TYPE_RC4;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_random_password">
        <type  value = "activex_cpp_data">
    char
        buffer [256],
        *table1 = "bcdfghjklmnpqrstvwxz",
        *table2 = "aeiouy";
    int
        index;
    short
        tab_idx,
        buf_size = 6;
    static int
        rand_factor = 1;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (size.vt != VT_ERROR
    &&  size.vt != VT_EMPTY
    &&  size.vt != VT_NULL)
      {
        VARIANT dest;
        memset (&dest, 0, sizeof (VARIANT));
        if (::VariantChangeType (&dest, &size, 0, VT_I2) == S_OK)
            buf_size = dest.iVal;
      }

    for (index = 0; index &lt; buf_size; index++)
      {
        if ((float)(int)(index / 2) == (float)index / 2.0)
          {
            tab_idx = random (20);
            buffer [index] = table1 [tab_idx];
          }
        else
          {
            tab_idx = random (6);
            buffer [index] = table2 [tab_idx];
          }
        rand_factor = tab_idx;
      }
    buffer [index] = '\0';
    *pVal = T2BSTR (buffer);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_hash">
        <type  value = "activex_cpp_data">
    byte
         *hash,
         *value;
    char
         *val;
    char
         buffer [50];
    int
         index;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    VARIANT2STRING (password, val);

    if (val == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    value = (byte *)val;
    hash  = sha1 (value, (qbyte)strlen((char *)value), NULL);
    for (index = 0; index &lt; SHA_DIGEST_SIZE; index++)
        sprintf (&(buffer [index * 2]), "%02X", hash [index]);
    *pVal = T2BSTR (buffer);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_temp_filename">
        <type  value = "activex_cpp_data">
    char
        *tempfile,
        *temp_dir,
        *default_ext;
    static qbyte
        file_number = 0;                /*  We generate unique file names    */
    FILE
        *fd;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2STRING (directory, temp_dir);
    VARIANT2STRING (extension, default_ext);

    if (default_ext == NULL)
        default_ext = "tmp";
    if (temp_dir == NULL)
      {
        temp_dir = env_get_string  ("TEMP", NULL);
        if (!temp_dir)
            temp_dir = env_get_string  ("TMP", NULL);
        if (!temp_dir)
            temp_dir = ".";
      }
    if (file_number == 0)
      {
        randomize ();
        file_number = random (32767);
      }
    tempfile = get_tmp_file_name (temp_dir, &file_number, default_ext);
    if (tempfile)
      {
        /* Create file for multithreading problem with concurrent request    */
        fd = fopen (tempfile, "wb");
        if (fd)
            fclose (fd);
        *pVal = T2BSTR (tempfile);
        mem_free (tempfile);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "save_encrypt">
        <type  value = "activex_cpp_data">
    char
        *str_key,
        *source,
        *target;
    BOOL
        delete_source = FALSE;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    VARIANT2STRING (key, str_key);

    if (source_file == NULL
    ||  target_file == NULL
    ||  str_key     == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    source = OLE2T (source_file);
    target = OLE2T (target_file);

    if (file_encrypt (source, target, (byte *)str_key, strlen (str_key),
                      m_crypt_type))
      {
        VARIANT2BOOL (remove_source, delete_source);

        if (delete_source)
            file_delete (source);
       }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "save_decrypt">
        <type  value = "activex_cpp_data">
    char
        *str_key,
        *source,
        *target;
    BOOL
        delete_source = FALSE;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    VARIANT2STRING (key, str_key);

    if (source_file == NULL
    ||  target_file == NULL
    ||  str_key     == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    source = OLE2T (source_file);
    target = OLE2T (target_file);

    if (file_decrypt (source, target, (byte *)str_key, strlen (str_key),
                      m_crypt_type))
      {
        VARIANT2BOOL (remove_source, delete_source);

        if (delete_source)
            file_delete (source);
       }
        </type>
    </rule>
<!-------------------------------------------------------------------------->
</object>
<test>
&lt;%
Set obj = Server.CreateObject ("scl.security")
temp_file = obj.temp_filename
obj.save_encrypt Server.MapPAth (".") & "\xmlstore.htm", temp_file , "xxx"
obj.save_decrypt temp_file, "c:\temp\test.htm", "xxx"
%&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;Random Pasword&lt;/td&gt;&lt;td&gt;Hash&lt;/td&gt;&lt;/tr&gt;
&lt;%
For index = 6 to 30
password = obj.random_password (index)
hash     = obj.hash (password)
%&gt;

&lt;tr&gt;&lt;td&gt;&lt;%=password %&gt;&lt;/td&gt;&lt;td&gt;&lt;%=hash%&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;%Next%&gt;


&lt;%
password = "BabelFood"
hash     = obj.hash (password)
%&gt;

&lt;tr&gt;&lt;td&gt;&lt;%=password %&gt;&lt;/td&gt;&lt;td&gt;&lt;%=hash%&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

</test>
<!--------------------------------------------------------------------------->
</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_sys"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09F72C5B8"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "sys">

<object
    name       = "sys"
    uuid       = "C036FC01-D336-11D3-B3AF-00E09872C5B4"
    class_uuid = "C036FC02-D336-11D3-B3AF-00E09872C5B4">
    <description>Component used for system method
    </description>
    <attribute name = "response"    type = "CComPtr&lt;IResponse&gt;"      />
    <attribute name = "page_started" type = "BOOL"                          />
    <property name = "execute">
        <parameter type = "BSTR"    name = "file"/>
        <parameter type = "VARIANT" name = "argument"    optional = "1"/>
        <parameter type = "VARIANT" name = "directory"   optional = "1"/>
        <parameter type = "VARIANT" name = "send_output" optional = "1"/>
        <return type = "BSTR" />
        <description>Execute a process and send output to the browser if needed
                     Return the standard output of the process
        </description>
        <rule name = "get_execute"/>
    </property>
    <property name = "total_memory">
        <return type = "long" />
        <description>Indicates the number of bytes of physical memory.</description>
        <rule name = "get_total_memory"/>
    </property>
    <property name = "available_memory">
        <return type = "long" />
        <description>Indicates the number of bytes of physical memory available.</description>
        <rule name = "get_avail_memory"/>
    </property>
   
    <method name = "OnStartPage" type = "event">
        <parameter type = "IUnknown*"    name = " pUnk"  />
        <description>Standard ASP interface</description>
        <rule name = "on_start_page"/>
    </method>
    <method name = "OnEndPage" type = "event">
        <description>Standard ASP interface</description>
        <rule name = "on_end_page"/>
    </method>

    <rule name = "get_execute">
        <type  value = "activex_cpp_data">
#define LINE_SIZE 2048
    char
        *exe_file,
        *cur_dir,
        *arg,
        *out,
        *temp_path,
        *buffer,
        line [LINE_SIZE + 1];
    Bool
        send2output;
    PROCESS
        proc;
    int
        file_handle = -1,
        status;
    long
        size,
        file_size,
        cur_pos = 0;
    qbyte
        index = 0;
    VARIANT
        out_buffer;
    char *
        ext_tab [] = {
           "exe",
           "com",
           "bat",
           "cmd",
           NULL
        };
    USES_CONVERSION;
#define SENDOUTPUT                                             \
          if (send2output && file_handle &gt;= 0)                 \
            {                                                  \
              while (eof (file_handle) == 0)                   \
                 {                                             \
                   size = read (file_handle, line, LINE_SIZE); \
                   if (size &gt; 0)                               \
                     {                                         \
                       line [size] = 0;                        \
                       out_buffer.vt      = VT_BSTR;           \
                       out_buffer.bstrVal = T2BSTR (line);     \
                       m_response-&gt; Write (out_buffer);        \
                     }                                         \
                 }                                             \
            }
        </type>
        <type  value = "activex_cpp">
    exe_file = OLE2T (file);
    VARIANT2STRING (argument,  arg);
    VARIANT2STRING (directory, cur_dir);
    VARIANT2BOOL   (send_output, send2output);

    /* Get temporary file for process output                                 */
    temp_path = getenv ("TEMP");
    out = get_tmp_file_name (temp_path, &index, "temp");

    /* Set the full path of executable and argument                          */
    exe_file = file_where_ext ('r', cur_dir, exe_file, (const char **)ext_tab);

    if (exe_file == NULL)
      {
         if (out)
             mem_free (out);
         RETURN_AND_RELEASE (S_FALSE);
      }

    if (arg)
        exe_file = xstrcpy (NULL, exe_file, " ", arg, NULL);
    else
        exe_file = mem_strdup (exe_file);

    proc = process_create (exe_file, NULL, cur_dir, NULL, out, NULL, NULL, FALSE);
    if (proc)
      {
        file_handle = process_open_io (out, 'r');       
        do {
          Sleep (100);
          status = process_status (proc);
          SENDOUTPUT;
        } while (status == PROCESS_RUNNING);

        process_close (proc);

        SENDOUTPUT;
      }

    *pVal = NULL;

    if (out)
      {
         if (file_handle &lt;= 0)
             file_handle = process_open_io (out, 'r');
         if (file_handle &gt;= 0)
           {
             lseek (file_handle, 0, SEEK_END);
             file_size = tell (file_handle);
             lseek (file_handle, 0, SEEK_SET);
             if (file_size &gt; 0)
               {
                 buffer = (char *)mem_alloc (file_size + 1);
                 if (buffer)
                   {
                     read (file_handle, buffer, file_size);
                     buffer [file_size] = 0;
                     *pVal = T2BSTR (buffer);
                     mem_free (buffer);
                   }
               }
           }
      }  
    if (file_handle &gt;= 0)
        close (file_handle);
    if (out)
      {
        file_delete (out);
        mem_free    (out);
      }
    if (exe_file)
        mem_free (exe_file);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_library">
        <type  value = "activex_cpp">
#include &lt;asptlb.h&gt;         // Active Server Pages Definitions

/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

/* Get a Boolean from a variant value                                       */
#define VARIANT2BOOL(var, str) {                                             \
    VARIANT dest;                                                            \
    str = FALSE;                                                             \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BOOL) == S_OK)           \
            str = (BOOL)dest.boolVal;                                        \
      }                                                                      \
}
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_total_memory">
        <type  value = "activex_cpp_data">
    MEMORYSTATUS
        mem_status;
        </type>
        <type  value = "activex_cpp">
    memset (&mem_status, 0, sizeof (MEMORYSTATUS));
    mem_status.dwLength = sizeof (MEMORYSTATUS);

    GlobalMemoryStatus (&mem_status);
    *pVal = mem_status.dwTotalPhys;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_avail_memory">
        <type  value = "activex_cpp_data">
    MEMORYSTATUS
        mem_status;
        </type>
        <type  value = "activex_cpp">
    memset (&mem_status, 0, sizeof (MEMORYSTATUS));
    mem_status.dwLength = sizeof (MEMORYSTATUS);

    GlobalMemoryStatus (&mem_status);
    *pVal = mem_status.dwAvailPhys;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "on_start_page" threadsafe = "1" use_cpp_object = "1">
        <type  value = "activex_cpp_data">
    CComPtr&lt;IGetContextProperties&gt;
        properties;
    CComBSTR
        request;
    CComVariant
        variant;
    IDispatch
        *dispatch;
    HRESULT
        hr;
        </type>
        <type  value = "activex_cpp">

    if (m_have_context == FALSE)
        hr = ::GetObjectContext (&m_spObjectContext);
    else
        hr = S_OK;
    if (SUCCEEDED (hr))
      {
        hr = m_spObjectContext-&gt; QueryInterface (IID_IGetContextProperties, (void **)&properties);
        if (SUCCEEDED (hr))
          {
            request = "Response";
            hr = properties-&gt; GetProperty (request, &variant);
            if (SUCCEEDED (hr))
              {
                if (V_VT(&variant) == VT_DISPATCH)
                  {
                    dispatch = V_DISPATCH (&variant);
                    if (dispatch != NULL)
                      {
                        hr = dispatch-&gt; QueryInterface (IID_IResponse, (void **)&m_response);
                        if (FAILED (hr))
                            return (hr);
                      }
                  }
              }
          }
        else
            return (hr);
      }
    else
        return (hr);

    m_page_started = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "on_end_page">
        <type  value = "activex_cpp">
    m_response.Release ();
        </type>
    </rule>

</object>
    <test>
&lt;%
 old_timeout = Session.TimeOut
 Session.TimeOut = 500
 Set obj = Server.CreateObject ("scl.sys")
 str = obj.execute ("autoexec.bat.bat", "", "c:\", 1)
 set obj = Nothing
 Session.TimeOut = old_timeout
&gt;>
    </test>
</component>



<component
    name        = "scl_symbol"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B4"
    version     = "1.1"
    description = "Standard Component Library"
    object_name = "symbol">
<!--------------------------------------------------------------------------->
<object
    name       = "symbol"
    uuid       = "835BBD61-FF15-11D3-8509-0000B494E941"
    class_uuid = "835BBD62-FF15-11D3-8509-0000B494E941">
    <attribute name = "table" type = "USYMTAB" reference = "yes"/>
    <description>Component with high level collection method
    </description>
    <method name = "add">
        <parameter type = "BSTR" name = "key"   />
        <parameter type = "BSTR" name = "value" />
        <parameter type = "VARIANT" name = "data" optional="1"/>
        <description>Add a symbol into the collection.</description>
        <rule name = "get_add"/>
    </method>
    <property name = "get">
        <parameter type = "BSTR"    name = "key"   />
        <parameter type = "VARIANT" name = "default_value" optional="1"/>
        <return type = "BSTR" />
        <description>Get symbol from collection</description>
        <rule name = "get_get"/>
    </property>
    <method name = "clear">
        <description>Clear the collection.</description>
        <rule name = "get_clear"/>
    </method>
    <property name = "substitute">
        <parameter type = "BSTR" name = "template_buf"   />
        <return type = "BSTR" />
        <description>Replace symbol call in a text template. The syntax to call symbol
         remplacement is $(symbol_key)</description>
        <rule name = "get_substitute"/>
    </property>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

        </type>
    </rule>
    <rule name = "get_add">
        <type  value = "activex_cpp_data">
    USYMBOL
        *symbol;
        </type>
        <type  value = "activex_cpp">
    if (m_table == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (key && value)
        symbol = usym_assume_symbol (m_table, key, value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_get">
        <type  value = "activex_cpp_data">
    UCODE
        *value;
        </type>
        <type  value = "activex_cpp">
    
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (m_table == NULL || key == NULL)
        RETURN_AND_RELEASE (S_OK);
    value = usym_get_value (m_table, key, NULL);
    if (value)
        *pVal = SysAllocString (value);
    else
    if (default_value.vt == VT_BSTR
    &&  default_value.bstrVal != NULL)
        *pVal = default_value.bstrVal;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_clear">
        <type  value = "activex_cpp">
    if (m_table)
        usym_empty_table (m_table);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_substitute">
        <type  value = "activex_cpp_data">
    UCODE
        *char_template = NULL,
        *result        = NULL;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (m_table == NULL
    ||  template_buf == NULL)
        RETURN_AND_RELEASE (S_OK);

    result = utok_subst (template_buf, m_table);
    if (result)
      {
        *pVal = SysAllocString (result);
        mem_free (result);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "constructor">
        <type  value = "activex_cpp">
    m_table = usym_create_table ();
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_table)
      {
        usym_delete_table (m_table);
        m_table = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
</object>

    <test>
&lt;%
Set obj = Server.CreateObject ("scl.symbol")
obj.add "key1", "value1"
obj.add "key2", "value2"
obj.add "key3", "value3"
%&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;Key&lt;/td&gt;&lt;td&gt;Value&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Key1&lt;/td&gt;&lt;td&gt;&lt;% = obj.get ("key1")%&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Key2&lt;/td&gt;&lt;td&gt;&lt;% = obj.get ("key2")%&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Key3&lt;/td&gt;&lt;td&gt;&lt;% = obj.get ("key3")%&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;h3&gt;Subtitution&lt;h3&gt;
&lt;PRE&gt;
    Before Substitution

&lt;%
   buffer = "This is a substitution test of $(key1), $(key2) and also $(key3)"
   Response.Write buffer
%&gt;

   After substitution

&lt;% = obj.substitute (buffer) %&gt;
&lt;/pre&gt;
    </test>


<!--------------------------------------------------------------------------->
</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_date"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B5"
    version     = "1.1"
    description = "Standard Component Library"
    object_name = "date">
<!--------------------------------------------------------------------------->
<object
    name       = "date"
    uuid       = "11073161-FFF9-11D3-B3AF-00E09872C5B1"
    class_uuid = "11073162-FFF9-11D3-B3AF-00E09872C5B1">
    <description>General Date, Time and Timestamp method. The timestamp is encoded
    into a double (8 bytes).
    </description>
    <property name = "timestamp">
        <return type = "VARIANT" />
        <description>Return the current timestamp</description>
        <rule name = "get_timestamp"/>
    </property>
    <property name = "date2ts">
        <parameter type = "VARIANT" name = "date"   />
        <parameter type = "VARIANT" name = "time"  optional="1" />
        <return type = "VARIANT" />
        <description>Encode a date/time (format 'yyyymmdd' and 'hhmmssmm') into a compressed value</description>
        <rule name = "get_make_timestamp"/>
    </property>
    <property name = "ts2date">
        <parameter type = "VARIANT" name = "value"   />
        <parameter type = "VARIANT" name = "picture" optional = "1"  />
        <return type = "BSTR" />
        <description>&lt;PRE&gt;Return the date part in format 'yyyymmdd' if picture is missing
        The picture is composed of any combination of these formats:
        cc        century 2 digits, 01-99
        y         day of year, 1-366
        yy        year 2 digits, 00-99
        yyyy      year 4 digits, 100-9999
        m         month, 1-12
        mm        month, 01-12
        mmm       month, 3 letters
        mmmm      month, full name
        MMM       month, 3 letters, ucase
        MMMM      month, full name, ucase
        d         day, 1-31
        dd        day, 01-31
        ddd       day of week, Sun-Sat
        dddd      day of week, Sunday-Saturday
        DDD       day of week, SUN-SAT
        DDDD      day of week, SUNDAY-SATURDAY
        w         day of week, 1-7 (1=Sunday)
        ww        week of year, 1-53
        q         year quarter, 1-4
        \x        literal character x
        other     literal character&lt;/PRE&gt;
        </description>
        <rule name = "get_timestamp_date"/>
    </property>
    <property name = "ts2time">
        <parameter type = "VARIANT" name = "value"   />
        <parameter type = "VARIANT" name = "picture" optional = "1"  />
        <return type = "BSTR" />
        <description>&lt;PRE&gt;Return the time part in format 'hhmmssmm' if picture is missing
        The picture is composed of any combination of these formats:
        h         hour, 0-23
        hh        hour, 00-23
        m         minute, 0-59
        mm        minute, 00-59
        s         second, 0-59
        ss        second, 00-59
        c         centisecond, 0-99
        cc        centisecond, 00-99
        a         a/p indicator - use 12-hour clock
        aa        am/pm indicator - use 12-hour clock
        A         A/P indicator - use 12-hour clock
        AA        AM/PM indicator - use 12-hour clock
        \x        literal character x
        other     literal character&lt;/PRE&gt;
        </description>
        <rule name = "get_timestamp_time"/>
    </property>
    <property name = "datediff">
        <parameter type = "VARIANT" name = "date1"   />
        <parameter type = "VARIANT" name = "date2"   />
        <return type = "long" />
        <description>Return the number of days between date1 and date2.
        The date value must be in format 'yyyymmdd'
        </description>
        <rule name = "get_datediff"/>
    </property>
    <property name = "tsdiff">
        <parameter type = "VARIANT" name = "ts1"   />
        <parameter type = "VARIANT" name = "ts2"   />
        <return type = "double" />
        <description>Return the number of second between timestamp 1 and
        timestamp2.
        </description>
        <rule name = "get_tsdiff"/>
    </property>
    <property name = "tsfuture">
        <parameter type = "VARIANT" name = "days"                  />
        <parameter type = "VARIANT" name = "csecs" optional = "1"/>
        <return type = "VARIANT"/>
        <description>Calculate a timestamp value in future. Add a number of
        days and centi-seconds to current timestamp.
        </description>
        <sample>
        csecond  = 18 * 360000
        futuredate = obj.tsfuture (2, csecond)
        Date and time in 2 days 18 hours is obj.ts2date (futuredate, "dd mmmm yyyy") & " " & obj.ts2time (futuredate, "hh:mm:ss")
        </sample>
        <rule name = "get_tsfuture"/>
    </property>
    <property name = "clock">
        <return type = "VARIANT"/>
        <description>Return a number in second of used processor time (used
        for profiling routine)
        </description>
        <rule name = "get_clock"/>
    </property>
    <property name = "is_valid_date">
        <parameter type = "long" name = "date"/>
        <return    type = "BOOL"/>
        <description>Returns TRUE if the date is valid or zero; returns FALSE if
        the date is not valid.</description>
        <rule name = "get_is_valid_date"/>
    </property>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2LONG(var, str) {                                             \
    VARIANT dest;                                                            \
    str = 0L;                                                                \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \
            str = dest.lVal;                                                 \
      }                                                                      \
}

#define VARIANT2DOUBLE(var, str) {                                           \
    char                                                                     \
        *val;                                                                \
    str = 0;                                                                 \
    VARIANT2STRING (var, val);                                               \
    if (val)                                                                 \
        str = atof (val);                                                    \
}
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_timestamp">
        <type  value = "activex_cpp_data">
    double
          timestamp;
    char
        buffer [40];
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    timestamp = gmtimestamp_now ();
    sprintf (buffer, "%f", timestamp);
    pVal-&gt; vt = VT_BSTR;
    pVal-&gt; bstrVal = T2BSTR (buffer);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_make_timestamp">
        <type  value = "activex_cpp_data">
    long
        num_date = 0,
        num_time = 0;
    double
          timestamp;
    char
        buffer [40];
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2LONG (date, num_date);
    VARIANT2LONG (time, num_time);

    local_to_gmt (num_date, num_time, &num_date, &num_time);

    timestamp = make_timestamp (num_date, num_time);
    sprintf (buffer, "%f", timestamp);
    pVal-&gt; vt = VT_BSTR;
    pVal-&gt; bstrVal = T2BSTR (buffer);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_tsfuture">
        <type  value = "activex_cpp_data">
    long
         date,
         time,
         nb_days,
         nb_csecs;
    double
          timestamp;
    char
        buffer [40];
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2LONG (days,  nb_days);
    VARIANT2LONG (csecs, nb_csecs);

    local_to_gmt (date_now (), time_now (), &date, &time);
    future_date  (&date, &time, nb_days, nb_csecs);

    timestamp = make_timestamp (date, time);

    sprintf (buffer, "%f", timestamp);

    pVal-&gt; vt      = VT_BSTR;
    pVal-&gt; bstrVal = T2BSTR (buffer);

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_clock">
        <type  value = "activex_cpp_data">
    char
        buffer [40];
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    sprintf (buffer, "%f", (double)clock () / (double)CLOCKS_PER_SEC);
    pVal-&gt; vt      = VT_BSTR;
    pVal-&gt; bstrVal = T2BSTR (buffer);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_is_valid_date">
        <type  value = "activex_cpp">
    *pVal = valid_date (date);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_timestamp_date">
        <type  value = "activex_cpp_data">
    long
        date,
        time;
    char
        *pict,
        buffer [200];
    double
        timestamp;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2DOUBLE (value, timestamp);

    if (timestamp > 2147483647)
        *pVal = T2BSTR ("00000000");
    else
      {
        VARIANT2STRING (picture, pict);
        date = timestamp_date (timestamp);
        time = timestamp_time (timestamp);
        gmt_to_local (date, time, &date, &time);
        if (pict == NULL)
            sprintf (buffer, "%08ld", (long)date);
        else
            strcpy (buffer, conv_date_pict (date, pict));
        *pVal = T2BSTR (buffer);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_timestamp_time">
        <type  value = "activex_cpp_data">
    long
        date,
        time;
    char
        *pict,
        buffer [20];
    double
        timestamp;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2DOUBLE (value, timestamp);

    if (timestamp > 2147483647)
        *pVal = T2BSTR ("00000000");
    else
      {
        VARIANT2STRING (picture, pict);
        date = timestamp_date (timestamp);
        time = timestamp_time (timestamp);
        gmt_to_local (date, time, &date, &time);

        if (pict == NULL)
            sprintf (buffer, "%08ld", (long)time);
        else
            strcpy (buffer, conv_time_pict (time, pict));
        *pVal = T2BSTR (buffer);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_datediff">
        <type  value = "activex_cpp_data">
    long
        date_1,
        date_2;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2LONG (date1, date_1);
    VARIANT2LONG (date2, date_2);
    
    *pVal = date_to_days  (date_1) - date_to_days  (date_2);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_tsdiff">
        <type  value = "activex_cpp_data">
    long
        date_diff;
    long
        time_1,
        time_2,
        time_diff;
    double
        ts_1,
        ts_2;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    VARIANT2DOUBLE (ts1, ts_1);
    VARIANT2DOUBLE (ts2, ts_2);

    time_1 = timestamp_time (ts_1);
    time_2 = timestamp_time (ts_2);

    date_diff = (long)(ts_1 - ts_2);
    time_diff = time_to_csecs (time_1) - time_to_csecs (time_2);
    if (time_diff &lt; 0)
        time_diff  = INTERVAL_DAY + time_diff;
    *pVal = ((date_diff * INTERVAL_DAY) + time_diff) / 100;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
</object>
<test>
&lt;%
    Set obj  = Server.CreateObject ("scl.date")
    uct_date = obj.timestamp
    ts1      = obj.date2ts (20010124, 12510000)
    ts2      = obj.date2ts (20010123, 15320000)
    nb_sec   = obj.tsdiff (ts1, ts2)
    nb_day   = int (nb_sec / 86400)
    nb_hour  = int ((nb_sec - (nb_day * 86400)) / 3600)
    nb_min   = int ((nb_sec - ((nb_day * 86400) + (nb_hour * 3600))) / 60)
%&gt;
&lt;PRE&gt;
Date now     : &lt;% =CStr (date_val) %&gt; =&gt; &lt;% = obj.ts2date (date_val) & " " & obj.ts2time (date_val)%&gt;
UCT Date now : &lt;% =CStr (uct_date) %&gt; =&gt; &lt;% = obj.ts2date (uct_date) & " " & obj.ts2time (uct_date)%&gt;
Christmas    : &lt;% =obj.date2ts (20001231, 02000000) %&gt;, midday: &lt;% =obj.date2ts (20001231, 14000000) %&gt;

Format:
    date: "dd mmmm yyyy" -&gt; &lt;% = obj.ts2date (date_val, "dd mmmm yyyy") %&gt;
    time: "hh:mm:ss:cc"  -&gt; &lt;% = obj.ts2time (date_val, "hh:mm:ss:cc") %&gt;

UCT2LOCAL: &lt;% =CStr (date_val) %&gt; =&gt; &lt;% = obj.ts2date (date_val) & " " & obj.ts2time (date_val)%&gt;

Date diff between 23/1/2001 15h32 and 24/1/2001 12h51
        &lt;%=nb_day%&gt; Days &lt;%=nb_hour%&gt; Hours &lt;%=nb_min%&gt; min
   
&lt;/PRE&gt;
</test>
<!--------------------------------------------------------------------------->
</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_mail"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B6"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "mail">
<!--------------------------------------------------------------------------->
<object
    name       = "mail"
    uuid       = "8266AEE1-07F0-11D4-A2BA-00304F02D3BC"
    class_uuid = "8266AEE2-07F0-11D4-A2BA-00304F02D3BC">
    <description>Component to send EMail (support attach of file)
    </description>
    <attribute name = "smtp"     type = "SMTP" reference = "yes"/>
    <attribute name = "feedback" type = "int"                   />
    <attribute name = "last_msg" type = "char" reference = "yes"/>
    <method name = "server">
        <parameter type = "BSTR"    name = "name"   />
        <description>Specifie SMTP server address</description>
        <rule name = "get_server"/>
    </method>
    <method name = "body">
        <parameter type = "BSTR"    name = "value"   />
        <description>Set message body</description>
        <rule name = "get_body"/>
    </method>
    <method name = "subject">
        <parameter type = "BSTR"    name = "value"   />
        <description>Set Subject of message</description>
        <rule name = "get_subject"/>
    </method>
    <method name = "sender">
        <parameter type = "BSTR"    name = "email"   />
        <parameter type = "VARIANT" name = "name" optional="1"  />
        <description>Specifie Sender name and email</description>
        <rule name = "get_sender"/>
    </method>
    <method name = "recipient">
        <parameter type = "BSTR"    name = "email"   />
        <parameter type = "VARIANT" name = "name" optional="1"  />
        <description>Specifie Recipient(s) name and email.
        The name parameter can be filled with: "realname" &lt;e-mail&gt;
        The separator for multiple recipient is ';'
        </description>
        <rule name = "get_recipient"/>
    </method>
    <method name = "cc">
        <parameter type = "BSTR"    name = "email"   />
        <parameter type = "VARIANT" name = "name" optional="1"  />
        <description>Specifie CC Recipient(s) name and email
        The name parameter can be filled with: "realname" &lt;e-mail&gt;
        The separator for multiple recipient is ';'</description>
        <rule name = "get_cc"/>
    </method>
    <method name = "bcc">
        <parameter type = "BSTR"    name = "email"   />
        <parameter type = "VARIANT" name = "name" optional="1"  />
        <description>Specifie BCC Recipient(s) name and email
        The name parameter can be filled with: "realname" &lt;e-mail&gt;
        The separator for multiple recipient is ';'</description>
        <rule name = "get_bcc"/>
    </method>
    <method name = "return_receipt_to">
        <parameter type = "BSTR"    name = "email"   />
        <description>Specifie Return a receipt to this email. Default is sender</description>
        <rule name = "get_return_receipt_to"/>
    </method>
    <method name = "attach_textual">
        <parameter type = "BSTR"    name = "files"   />
        <description>Set attach list of textual file</description>
        <rule name = "get_attach_textual"/>
    </method>
    <method name = "attach_binary">
        <parameter type = "BSTR"    name = "files" />
        <description>Set attach list of binary files</description>
        <rule name = "get_attach_binary"/>
    </method>
    <method name = "set_trace">
        <parameter type = "BSTR"    name = "log_file" />
        <description>Enable log of return message from smtp server into a file</description>
        <rule name = "get_set_trace"/>
    </method>
    <method name = "send">
        <parameter type = "VARIANT" name = "server"  optional="1"/>
        <parameter type = "VARIANT" name = "from"    optional="1"/>
        <parameter type = "VARIANT" name = "to"      optional="1"/>
        <parameter type = "VARIANT" name = "subject" optional="1"/>
        <parameter type = "VARIANT" name = "body"    optional="1"/>
        <description>Send Email</description>
        <rule name = "get_send"/>
    </method>
    <property name = "feedback">
        <return type = "int" />
        <description>Return a feedback value after send email.
        If value is not 0, it is a error code.
        </description>
        <rule name = "get_feedback"/>
    </property>
    <property name = "strfeedback">
        <return type = "BSTR" />
        <description>Return a feedback description after send email.
        </description>
        <rule name = "get_strfeedback"/>
    </property>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_server">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strSmtpServer)
      {
        mem_free (m_smtp-&gt; strSmtpServer);
        m_smtp-&gt; strSmtpServer = NULL;
      }
    if (name)
      {
        value = OLE2T (name);
        if (value)
            m_smtp-&gt; strSmtpServer = mem_strdup (value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_body">
        <type  value = "activex_cpp_data">
    char
        *val;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strMessageBody)
      {
        mem_free (m_smtp-&gt; strMessageBody);
        m_smtp-&gt; strMessageBody = NULL;
      }
    if (value)
      {
        val = OLE2T (value);
        if (val)
            m_smtp-&gt; strMessageBody = mem_strdup (val);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_subject">
        <type  value = "activex_cpp_data">
    char
        *val;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strSubject)
      {
        mem_free (m_smtp-&gt; strSubject);
        m_smtp-&gt; strSubject = NULL;
      }
    if (value)
      {
        val = OLE2T (value);
        if (val)
            m_smtp-&gt; strSubject = mem_strdup (val);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_sender">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strSenderUserId)
      {
        mem_free (m_smtp-&gt; strSenderUserId);
        m_smtp-&gt; strSenderUserId = NULL;
      }
    if (m_smtp-&gt; strFullSenderUserId)
      {
        mem_free (m_smtp-&gt; strFullSenderUserId);
        m_smtp-&gt; strFullSenderUserId = NULL;
      }

    if (email)
      {
        value = OLE2T (email);
        if (value)
            m_smtp-&gt; strSenderUserId = mem_strdup (value);
      }

    value = NULL;

    VARIANT2STRING (name, value);

    if (value)
        m_smtp-&gt; strFullSenderUserId = mem_strdup (value);
       </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_recipient">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strDestUserIds)
      {
        mem_free (m_smtp-&gt; strDestUserIds);
        m_smtp-&gt; strDestUserIds = NULL;
      }
    if (m_smtp-&gt; strFullDestUserIds)
      {
        mem_free (m_smtp-&gt; strFullDestUserIds);
        m_smtp-&gt; strFullDestUserIds = NULL;
      }

    if (email)
      {
        value = OLE2T (email);
        if (value)
            m_smtp-&gt; strDestUserIds = mem_strdup (value);
      }

    VARIANT2STRING (name, value);
    if (value)
        m_smtp-&gt; strFullDestUserIds = mem_strdup (value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_cc">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strCcUserIds)
      {
        mem_free (m_smtp-&gt; strCcUserIds);
        m_smtp-&gt; strCcUserIds = NULL;
      }
    if (m_smtp-&gt; strFullCcUserIds)
      {
        mem_free (m_smtp-&gt; strFullCcUserIds);
        m_smtp-&gt; strFullCcUserIds = NULL;
      }

    if (email)
      {
        value = OLE2T (email);
        if (value)
            m_smtp-&gt; strCcUserIds = mem_strdup (value);
      }

    VARIANT2STRING (name, value);
    if (value)
        m_smtp-&gt; strFullCcUserIds = mem_strdup (value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_bcc">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (m_smtp-&gt; strBccUserIds)
      {
        mem_free (m_smtp-&gt; strBccUserIds);
        m_smtp-&gt; strBccUserIds = NULL;
      }
    if (m_smtp-&gt; strFullBccUserIds)
      {
        mem_free (m_smtp-&gt; strFullBccUserIds);
        m_smtp-&gt; strFullBccUserIds = NULL;
      }

    if (email)
      {
        value = OLE2T (email);
        if (value)
            m_smtp-&gt; strBccUserIds = mem_strdup (value);
      }

    VARIANT2STRING (name, value);
    if (value)
        m_smtp-&gt; strFullBccUserIds = mem_strdup (value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_return_receipt_to">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strRetPathUserId)
      {
        mem_free (m_smtp-&gt; strRetPathUserId);
        m_smtp-&gt; strRetPathUserId = NULL;
      }
    if (email)
      {
        value = OLE2T (email);
        if (value)
            m_smtp-&gt; strRetPathUserId = mem_strdup (value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_attach_textual">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (m_smtp-&gt; strTxtFiles)
      {
        mem_free (m_smtp-&gt; strTxtFiles);
        m_smtp-&gt; strTxtFiles = NULL;
      }
    if (files)
      {
        value = OLE2T (files);
        if (value)
            m_smtp-&gt; strTxtFiles = mem_strdup (value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_attach_binary">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strBinFiles)
      {
        mem_free (m_smtp-&gt; strBinFiles);
        m_smtp-&gt; strBinFiles = NULL;
      }
    if (files)
      {
        value = OLE2T (files);
        if (value)
            m_smtp-&gt; strBinFiles = mem_strdup (value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_set_trace">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_smtp-&gt; strDebugFile)
      {
        mem_free (m_smtp-&gt; strDebugFile);
        m_smtp-&gt; strDebugFile = NULL;
      }
    m_smtp-&gt; debug = 0;

    if (log_file)
      {
        value = OLE2T (log_file);
        if (value)
          {
            m_smtp-&gt; strDebugFile = mem_strdup (value);
            m_smtp-&gt; debug        = 1;
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_send">
        <type  value = "activex_cpp_data">
    char
        *value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_feedback = 1;
#define GET_PARAM(param, dest)                                                 \
    /* Check server value                                                    */\
    VARIANT2STRING (param, value);                                             \
    if (value)                                                                 \
      {                                                                        \
        if (m_smtp-&gt; dest)                                                     \
            mem_free (m_smtp-&gt; dest);                                          \
        m_smtp-&gt; dest = value;                                                 \
      }
    GET_PARAM (server, strSmtpServer)
    GET_PARAM (from,    strSenderUserId)
    GET_PARAM (to,      strDestUserIds)
    GET_PARAM (subject, strSubject)
    GET_PARAM (body,    strMessageBody)

    if (m_smtp-&gt; strSmtpServer   == NULL
    ||  m_smtp-&gt; strSenderUserId == NULL
    ||  m_smtp-&gt; strDestUserIds  == NULL
    ||  m_smtp-&gt; strSubject      == NULL
    ||  m_smtp-&gt; strMessageBody  == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    mem_strfree (&m_last_msg);
    m_smtp-&gt; encode_type = ENCODE_BASE64;
    m_smtp-&gt; connect_retry_cnt = 3;
    if (m_smtp-&gt; strRetPathUserId == NULL)
        m_smtp-&gt; strRetPathUserId = mem_strdup (m_smtp-&gt; strSenderUserId);
    m_smtp-&gt; strMailerName        = "iMatix Email component 1.0";
    m_feedback = smtp_send_mail_ex (m_smtp);
    if (m_feedback != 0)
        m_last_msg = mem_strdup (m_smtp-&gt; strlast_smtp_message);

    if (m_smtp-&gt; strSmtpServer)
        mem_free (m_smtp-&gt; strSmtpServer);
    if (m_smtp-&gt; strMessageBody)
        mem_free (m_smtp-&gt; strMessageBody);
    if (m_smtp-&gt; strSubject)
        mem_free (m_smtp-&gt; strSubject);
    if (m_smtp-&gt; strSenderUserId)
        mem_free (m_smtp-&gt; strSenderUserId);
    if (m_smtp-&gt; strFullSenderUserId)
        mem_free (m_smtp-&gt; strFullSenderUserId);
    if (m_smtp-&gt; strDestUserIds)
        mem_free (m_smtp-&gt; strDestUserIds);
    if (m_smtp-&gt; strFullDestUserIds)
        mem_free (m_smtp-&gt; strFullDestUserIds);
    if (m_smtp-&gt; strCcUserIds)
        mem_free (m_smtp-&gt; strCcUserIds);
    if (m_smtp-&gt; strFullCcUserIds)
        mem_free (m_smtp-&gt; strFullCcUserIds);
    if (m_smtp-&gt; strBccUserIds)
        mem_free (m_smtp-&gt; strBccUserIds);
    if (m_smtp-&gt; strFullBccUserIds)
        mem_free (m_smtp-&gt; strFullBccUserIds);
    if (m_smtp-&gt; strRetPathUserId)
        mem_free (m_smtp-&gt; strRetPathUserId);
    if (m_smtp-&gt; strRrcpUserId)
        mem_free (m_smtp-&gt; strRrcpUserId);
    if (m_smtp-&gt; strMsgComment)
        mem_free (m_smtp-&gt; strMsgComment);
    if (m_smtp-&gt; strBinFiles)
        mem_free (m_smtp-&gt; strBinFiles);
    if (m_smtp-&gt; strTxtFiles)
        mem_free (m_smtp-&gt; strTxtFiles);
    if (m_smtp-&gt; strDebugFile)
        mem_free (m_smtp-&gt; strDebugFile);
    memset (m_smtp, 0, sizeof (SMTP));
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_feedback">
        <type  value = "activex_cpp">
    *pVal = m_feedback;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_strfeedback">
        <type  value = "activex_cpp_data">
    char
        buffer [600];
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    strcpy (buffer, smtp_error_description (m_feedback));
    if (m_last_msg)
        xstrcat (buffer, ", Last message: ", m_last_msg, NULL);
    *pVal = T2BSTR (buffer);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "constructor">
        <type  value = "activex_cpp">
    m_smtp = (SMTP *)mem_alloc (sizeof (SMTP));
    if (m_smtp)
        memset (m_smtp, 0, sizeof (SMTP));
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_smtp)
      {
        if (m_smtp-&gt; strSmtpServer)
            mem_free (m_smtp-&gt; strSmtpServer);
        if (m_smtp-&gt; strMessageBody)
            mem_free (m_smtp-&gt; strMessageBody);
        if (m_smtp-&gt; strSubject)
            mem_free (m_smtp-&gt; strSubject);
        if (m_smtp-&gt; strSenderUserId)
            mem_free (m_smtp-&gt; strSenderUserId);
        if (m_smtp-&gt; strFullSenderUserId)
            mem_free (m_smtp-&gt; strFullSenderUserId);
        if (m_smtp-&gt; strDestUserIds)
            mem_free (m_smtp-&gt; strDestUserIds);
        if (m_smtp-&gt; strFullDestUserIds)
            mem_free (m_smtp-&gt; strFullDestUserIds);
        if (m_smtp-&gt; strCcUserIds)
            mem_free (m_smtp-&gt; strCcUserIds);
        if (m_smtp-&gt; strFullCcUserIds)
            mem_free (m_smtp-&gt; strFullCcUserIds);
        if (m_smtp-&gt; strBccUserIds)
            mem_free (m_smtp-&gt; strBccUserIds);
        if (m_smtp-&gt; strFullBccUserIds)
            mem_free (m_smtp-&gt; strFullBccUserIds);
        if (m_smtp-&gt; strRetPathUserId)
            mem_free (m_smtp-&gt; strRetPathUserId);
        if (m_smtp-&gt; strRrcpUserId)
            mem_free (m_smtp-&gt; strRrcpUserId);
        if (m_smtp-&gt; strMsgComment)
            mem_free (m_smtp-&gt; strMsgComment);
        if (m_smtp-&gt; strBinFiles)
            mem_free (m_smtp-&gt; strBinFiles);
        if (m_smtp-&gt; strTxtFiles)
            mem_free (m_smtp-&gt; strTxtFiles);
        if (m_smtp-&gt; strDebugFile)
            mem_free (m_smtp-&gt; strDebugFile);
        mem_free (m_smtp);
        m_smtp = NULL;
      }

    if (m_last_msg)
        mem_free (m_last_msg);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
</object>
<test>
&lt;%
Set obj = Server.CreateObject ("scl.mail")
    obj.server "localhost"
    obj.sender "pascal@localhost"
    obj.recipient "test@localhost"
    obj.subject   "Test of SCL email"
    obj.body      "Message from space :-)"
    obj.attach_textual "c:\test.txt;c:\test2.txt"
    obj.attach_binary  "c:\kill.exex"
    'obj.send
    If obj.feedback = 0 Then
       Response.Write "&lt;p&gt;Email Sent"
    Else
       Response.Write "&lt;p&gt;Error on send email: " & obj.feedback & "(" & obj.strfeedback & ")"
    End If
%&gt;
</test>
<!--------------------------------------------------------------------------->
</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_workflow"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B7"
    version     = "1.1"
    description = "Standard Component Library"
    object_name = "workflow">
<!--------------------------------------------------------------------------->
<object
    name       = "workflow"
    uuid       = "8766AEE1-07F8-13D4-A7BA-44304FA2D3BC"
    class_uuid = "8766AEE2-07F8-13D4-A7BA-44304FA2D3BC">
    <description>Component to Help workflow
    </description>
    <attribute name = "action"       type = "SYMTAB" reference = "yes"/>
    <attribute name = "state"        type = "SYMTAB" reference = "yes"/>
    <attribute name = "method"       type = "SYMTAB" reference = "yes"/>
    <attribute name = "method_label" type = "SYMTAB" reference = "yes"/>
    <attribute name = "text"         type = "SYMTAB" reference = "yes"/>
    <attribute name = "hint"         type = "SYMTAB" reference = "yes"/>
    <attribute name = "action_arg"   type = "SYMTAB" reference = "yes"/>
    <attribute name = "valid"        type = "bool"/>
    <method name = "load">
        <parameter type = "BSTR"    name = "workflow"   />
        <parameter type = "VARIANT" name = "script"     />
        <description>Load workflow file and execute GSL script if specified
        </description>
        <rule name = "load"/>
    </method>
    <method name = "dump">
        <parameter type = "BSTR"    name = "file_name"   />
        <description>Save all symbol table into a file
        </description>
        <rule name = "dump"/>
    </method>
    <property name = "action_list">
        <parameter type = "BSTR"    name = "state"  />
        <parameter type = "BSTR"    name = "event"  />
        <return type = "BSTR" />
        <description>Return the action list for a specified state and event
        </description>
        <rule name = "get_action_list"/>
    </property>
    <property name = "action_args">
        <parameter type = "BSTR"    name = "state"  />
        <parameter type = "BSTR"    name = "event"  />
        <return type = "BSTR" />
        <description>Return the action argument for a specified state and event
        </description>
        <rule name = "get_action_arg"/>
    </property>
    <property name = "next_state">
        <parameter type = "BSTR"    name = "state"  />
        <parameter type = "BSTR"    name = "event"  />
        <return type = "BSTR" />
        <description>Return the next state for a specified state and event
        </description>
        <rule name = "get_next_state"/>
    </property>
    <property name = "method">
        <parameter type = "BSTR"    name = "state"  />
        <parameter type = "BSTR"    name = "role"  />
        <return type = "BSTR" />
        <description>Return the method name for a specified state and role
        </description>
        <rule name = "get_method"/>
    </property>
    <property name = "method_label">
        <parameter type = "BSTR"     name = "state"  />
        <parameter type = "BSTR"     name = "role"  />
        <parameter type = "VARIANT"  name = "codepage" optional = "1" />
        <return type = "BSTR" />
        <description>Return the method label for a specified state and role
        </description>
        <rule name = "get_method_label"/>
    </property>
    <property name = "state_text">
        <parameter type = "BSTR"     name = "state"  />
        <parameter type = "VARIANT"  name = "codepage" optional = "1" />
        <return type = "BSTR" />
        <description>Return the text specified for a state
        </description>
        <rule name = "get_state_text"/>
    </property>
    <property name = "hint">
        <parameter type = "BSTR"     name = "method"  />
        <parameter type = "VARIANT"  name = "codepage" optional = "1" />
        <return type = "BSTR" />
        <description>Return the hint text for a method
        </description>
        <rule name = "get_hint"/>
    </property>
    <property name = "valid">
        <return type = "BOOL" />
        <description>Indicates if last executed method was valid</description>
        <rule name = "get_valid"/>
        <sample>If wf.valid Then
                End If</sample>
    </property>

    <rule name = "include_definition">
        <type  value = "activex_cpp">
#include "ggcode.h"

/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2LONG(var, str) {                                             \
    VARIANT dest;                                                            \
    str = 0L;                                                                \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \
            str = dest.lVal;                                                 \
      }                                                                      \
}
        </type>
    </rule>

    <rule name = "load">
        <type  value = "activex_cpp_data">
    XML_ITEM
        *xml_switches,
        *root  = NULL,
        *state = NULL,
        *item  = NULL;
    char
        *state_name,
        key [256],
        *str_script;

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (m_action)
        sym_delete_table (m_action);
    if (m_action_arg)
        sym_delete_table (m_action_arg);
    if (m_state)
        sym_delete_table (m_state);
    if (m_method)
        sym_delete_table (m_method);
    if (m_method_label)
        sym_delete_table (m_method_label);
    if (m_text)
        sym_delete_table (m_text);
    if (m_hint)
        sym_delete_table (m_hint);

    m_action       = sym_create_table ();
    m_action_arg   = sym_create_table ();
    m_state        = sym_create_table ();
    m_method       = sym_create_table ();
    m_method_label = sym_create_table ();
    m_text         = sym_create_table ();
    m_hint         = sym_create_table ();

    VARIANT2STRING (script, str_script);

    if (xml_load (&root, NULL, OLE2T (workflow)) != 0)
        RETURN_AND_RELEASE (S_FALSE);

    if (str_script)
      {
        xml_switches = xml_new (NULL, "switches", NULL);
        xml_put_attr (xml_switches, "shuffle",    "1");
        xml_put_attr (xml_switches, "ignorecase", "1");
        xml_put_attr (xml_switches, "template",   "1");
        xml_put_attr (xml_switches, "me",         "workflow");
        xml_put_attr (xml_switches, "date", conv_date_pict (date_now (), "yyyy/mm/dd"));
        xml_put_attr (xml_switches, "time", conv_time_pict (time_now (), "hh:mm:ss"));
        xml_put_attr (xml_switches, "script", str_script);

        gg_send_stdout (NULL, FALSE);

        item = xml_first_child (root);
        gg_code (item, xml_switches);
        xml_free (xml_switches);
      }

    item = xml_first_child (root);
    FORCHILDREN (state, item)
      {
        if (streq (xml_item_name (state), "state"))
          {
            state_name = xml_get_attr (state, "name", "");
            sym_assume_symbol (m_text, state_name, xml_get_attr (state, "text", ""));

            FORCHILDREN (item, state)
              {
                if (streq (xml_item_name (item), "event"))
                  {
                    sprintf (key, "%s_%s", state_name, xml_get_attr (item, "name", ""));
                    sym_assume_symbol (m_action,     key, xml_get_attr (item,  "actionlist", ""));
                    sym_assume_symbol (m_state,      key, xml_get_attr (item,  "nextstate", state_name));
                    sym_assume_symbol (m_action_arg, key, xml_get_attr (item,  "argument", ""));
                  }
                else
                if (streq (xml_item_name (item), "role"))
                  {
                    sprintf (key, "%s_%s", state_name, xml_get_attr (item, "name", ""));
                    sym_assume_symbol (m_method, key, xml_get_attr (item,  "methods", ""));
                    sym_assume_symbol (m_method_label, key, xml_get_attr (item,  "methods_label", ""));
                  }
              }
          }
        else
        if (streq (xml_item_name (state), "method"))
            sym_assume_symbol (m_hint,
                               xml_get_attr (state, "name", ""),
                               xml_get_attr (state, "hint", ""));
      }
    xml_free (root);

    if (m_action-> size &gt; 0
    &&  m_state->  size &gt; 0
    &&  m_method-> size &gt; 0)
        m_valid = TRUE;
        </type>
    </rule>

    <rule name = "dump">
        <type  value = "activex_cpp_data">
    FILE
        *file;
    char
        *fname;
    SYMBOL
        *symbol;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    fname = OLE2T (file_name);

    file = fopen (fname, "w");
    if (file)
      {
        fprintf (file, "Action list\n");
        fprintf (file, "-----------\n");
        if (m_action)
          {
            for (symbol = m_action-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }

        fprintf (file, "Action argument list\n");
        fprintf (file, "--------------------\n");
        if (m_action)
          {
            for (symbol = m_action_arg-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }

        fprintf (file, "\nNext state list\n");
        fprintf (file, "----------------\n");
        if (m_state)
          {
            for (symbol = m_state-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }
        fprintf (file, "\nMethods list\n");
        fprintf (file, "-------------\n");
        if (m_method)
          {
            for (symbol = m_method-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }
        if (m_method_label)
          {
            fprintf (file, "\nMethods label list\n");
            fprintf (file, "-------------------\n");
            for (symbol = m_method_label-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }
        fprintf (file, "\nState text list\n");
        fprintf (file, "----------------\n");
        if (m_text)
          {
            for (symbol = m_text-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }
        fprintf (file, "\nhint list\n");
        fprintf (file, "-----------\n");
        if (m_hint)
          {
            for (symbol = m_hint-> symbols; symbol; symbol = symbol-> next)
                fprintf (file, "%-50s %s\n", symbol-> name, symbol-> value);
          }
        fclose (file);
        m_valid = TRUE;
      }
        </type>
    </rule>

    <rule name = "get_action_list">
        <type  value = "activex_cpp_data">
    char
        *value,
        key [256];

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_action)
      {
        sprintf (key, "%s_%s", OLE2T (state), OLE2T (event));
        value = sym_get_value (m_action, key, "");
        if (*value != '\0')
            m_valid = TRUE;
        *pVal = T2BSTR (value);
      }
        </type>
    </rule>

    <rule name = "get_action_arg">
        <type  value = "activex_cpp_data">
    char
        *value,
        key [256];

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_action_arg)
      {
        sprintf (key, "%s_%s", OLE2T (state), OLE2T (event));
        value = sym_get_value (m_action_arg, key, "");
        if (*value != '\0')
            m_valid = TRUE;
        *pVal = T2BSTR (value);
      }
        </type>
    </rule>

    <rule name = "get_next_state">
        <type  value = "activex_cpp_data">
    char
        *value,
        key [256];

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_state)
      {
        sprintf (key, "%s_%s", OLE2T (state), OLE2T (event));
        value = sym_get_value (m_state, key, "");
        if (*value != '\0')
            m_valid = TRUE;
        *pVal = T2BSTR (value);
      }
        </type>
    </rule>

    <rule name = "get_method">
        <type  value = "activex_cpp_data">
    char
        *value,
        key [256];
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_method)
      {
        sprintf (key, "%s_%s", OLE2T (state), OLE2T (role));
        value = sym_get_value (m_method, key, "");
        if (*value != '\0')
            m_valid = TRUE;
        *pVal = T2BSTR (value);
      }
        </type>
    </rule>

    <rule name = "get_method_label">
        <type  value = "activex_cpp_data">
    char
        *value,
        key [256];
    long
        codep;
    UCODE
        *val;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_method_label)
      {
        VARIANT2LONG (codepage, codep);
        sprintf (key, "%s_%s", OLE2T (state), OLE2T (role));
        value = sym_get_value (m_method_label, key, "");
        if (*value != '\0')
            m_valid = TRUE;
        if (codep == 0)
            *pVal = T2BSTR (value);
        else
          {
            val = ascii2ucode_ex (value, codep);
            if (val)
              {
                *pVal = SysAllocString (val);
                mem_free (val);
              }
          }
      }
        </type>
    </rule>

    <rule name = "get_state_text">
        <type  value = "activex_cpp_data">
    char
        *value;
    long
        codep;
    UCODE
        *val;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_text)
      {
        VARIANT2LONG (codepage, codep);
        value = sym_get_value (m_text, OLE2T (state), "");
        if (*value != '\0')
            m_valid = TRUE;
        if (codep == 0)
            *pVal = T2BSTR (value);
        else
          {
            val = ascii2ucode_ex (value, codep);
            if (val)
              {
                *pVal = SysAllocString (val);
                mem_free (val);
              }
          }
      }
        </type>
    </rule>

    <rule name = "get_hint">
        <type  value = "activex_cpp_data">
    char
        *value;
    long
        codep;
    UCODE
        *val;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    if (m_hint)
      {
        VARIANT2LONG (codepage, codep);
        value = sym_get_value (m_hint, OLE2T (method), "");
        if (*value != '\0')
            m_valid = TRUE;
        if (codep == 0)
            *pVal = T2BSTR (value);
        else
          {
            val = ascii2ucode_ex (value, codep);
            if (val)
              {
                *pVal = SysAllocString (val);
                mem_free (val);
              }
          }
      }
        </type>
    </rule>

    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_action)
        sym_delete_table (m_action);
    if (m_action_arg)
        sym_delete_table (m_action_arg);
    if (m_state)
        sym_delete_table (m_state);
    if (m_method)
        sym_delete_table (m_method);
    if (m_method_label)
        sym_delete_table (m_method_label);
    if (m_text)
        sym_delete_table (m_text);
    if (m_hint)
        sym_delete_table (m_hint);
        </type>
    </rule>

    <rule name = "get_valid">
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = m_valid;
        </type>
    </rule>
</object>
<test>
&lt;%
 Set obj = Server.CreateObject ("scl.workflow")
 set obj = nothing
%&gt;
</test>
</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_upload"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B8"
    version     = "1.1"
    description = "Standard Component Library"
    object_name = "upload">
<additional_source file = "fcrypt.c" />

<!--------------------------------------------------------------------------->
<object
    name       = "upload"
    uuid       = "8766AFF1-A7F8-1ED4-A7BA-47894FA2DAFC"
    class_uuid = "8766AFF2-A7F8-1ED4-A7BA-47894FA2DAFC">
    <description>Decode form posted in multi-part format and manage uploaded files
    Component to use onlyu in ASP page.
    </description>
    <attribute name = "request"      type = "CComPtr&lt;IRequest&gt;"       />
    <attribute name = "response"     type = "CComPtr&lt;IResponse&gt;"      />
    <attribute name = "server"       type = "CComPtr&lt;IServer&gt;"        />
    <attribute name = "session"      type = "CComPtr&lt;ISessionObject&gt;" />
    <attribute name = "form"         type = "USYMTAB" reference = "yes"     />
    <attribute name = "files"        type = "USYMTAB" reference = "yes"     />
    <attribute name = "page_started" type = "BOOL"                          />
    <attribute name = "nb_file"      type = "long"                          />
    <attribute name = "allowed_file" type = "USYMTAB" reference = "yes"     />
    <attribute name = "denied_file"  type = "USYMTAB" reference = "yes"     />
    <attribute name = "crypt_type"   type = "short"                         />
    <method name = "data">
        <description>Decode data posted by the browser and save in collection.
        You must save upload file before and of asp page. At end of ASP page,
        The content of form and file collections is removed from memory.
        </description>
        <rule name = "data"/>
    </method>
    <property name = "form">
        <parameter type = "VARIANT"    name = "field_name"  />
        <return type = "BSTR" />
        <description>Return a field value of a form field. The field name is
        case incensitif.
        </description>
        <rule name = "get_form"/>
    </property>
    <property name = "files_count">
        <return type = "long" />
        <description>Return the number of file uploaded
        </description>
        <rule name = "get_file_count"/>
    </property>
    <method name = "OnStartPage" type = "event">
        <parameter type = "IUnknown*"    name = " pUnk"  />
        <description>Standard ASP interface</description>
        <rule name = "on_start_page"/>
    </method>
    <method name = "OnEndPage" type = "event">
        <description>Standard ASP interface</description>
        <rule name = "on_end_page"/>
    </method>
    <method name = "dump">
        <parameter type = "BSTR" name = "file_name"/>
        <description>Dump content of the form collection into a file
        </description>
        <rule name = "dump"/>
    </method>
    <property name = "allowed_files">
        <parameter type = "VARIANT" name = "file_list" />
        <description>Set the allowed upload file list.
        Require all allowed extension, separate with ','.
        </description>
        <sample>upload.allowed_files "htm,txt,rtf"</sample>
        <rule name = "allowed_list"/>
    </property>
    <property name = "denied_files">
        <parameter type = "VARIANT" name = "file_list" />
        <description>Set the denied upload file list.
        Require all denied extension, separate with ','.
        </description>
        <sample>upload.denied_files "com,bat,exe,dll"</sample>
        <rule name = "denied_list"/>
    </property>
    <property name = "save">
        <parameter type = "VARIANT"    name = "field_name"                />
        <parameter type = "VARIANT"    name = "output_dir" optional = "1" />
        <parameter type = "VARIANT"    name = "file_name"  optional = "1" />
        <parameter type = "VARIANT"    name = "key"        optional = "1" />
        <return type = "BSTR"/>
        <description>Save the file of this field content. You can specify a
        new name and a default directory for this file.
        Return the saved file name.
        If a value for key is specified, the file is compressed and crypted
        with this key. If file name is NULL, use a temporary file name with
        the same extension.
        If no directory is specified , use the 'TEMP' directory to store file.
        If the specified directory is not a full path, add the specified
        directory to the current directory.
        </description>
        <sample>
        This save the file of field 'file1' into a temporary file name into
        subdirectory upload and encrypted with the key 'this is the key'

        fname = Upload.save ("file1", Server.MapPath (".") & "\upload", "", "this is the key")

        ex. of value of fname: '00002B95.doc'
        </sample>
        <rule name = "save"/>
    </property>
    <method name = "download" >
        <parameter type = "VARIANT" name = "file_name"                 />
        <parameter type = "VARIANT" name = "directory"   optional = "1"/>
        <parameter type = "VARIANT" name = "key"         optional = "1"/>
        <description>Download a file to the browser.
        If a directory are used, the directory is added to file name else use the current directory.
        If the directory is relatif (not full path) the current directory is added to the directory.
        If a key is specified, the file is decrypted at run time with this key.
        </description>
        <sample>This download a file, the URL is in the session a it is a encrypted file

        set upload = Server.CreateObject ("sstk.upload")
        upload.download session ("download_file"), "", "this is the key"
        Set upload = Nothing

        </sample>
        <rule name = "download"/>
    </method>
    <method name = "set_crypt_type">
        <parameter type = "VARIANT" name = "type" />
        <description>Set the algorythm to crypt and decrypt file.
        Supported algorythm is : DES, 3DES, IDEA, RC4
        Default algorythm is RC4
        </description>
        <rule name = "set_crypt"/>
    </method>
    <method name = "save2text">
        <parameter type = "BSTR" name = "file_name" />
        <parameter type = "BSTR" name = "content"   />
        <description>
        Save a unicode buffer content into a ascii text file.
        Use the session codepage to convert unicode to ascii
        (or multibyte)
        </description>
        <rule name = "save2text"/>
    </method>
    <function name = "free_tables">
        <description>Free all symbol tables</description>
        <rule name = "free_tables"/>
    </function>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
#include "fcrypt.h"

/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2BSTR(var, str) {                                            \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = dest.bstrVal;                                              \
      }                                                                      \
}
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_library">
        <type  value = "activex_cpp">
#include &lt;asptlb.h&gt;         // Active Server Pages Definitions
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "constructor">
        <type  value = "activex_cpp">
    m_crypt_type = CRYPT_TYPE_RC4;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "free_tables">
        <type  value = "activex_cpp_data">
    USYMBOL
        *symbol;
        </type>
        <type  value = "activex_cpp">

    if (m_form)
      {
        usym_delete_table (m_form);
        m_form = NULL;
      }

    if (m_files)
      {
        for (symbol = m_files-> symbols; symbol; symbol = symbol-> next)
          {
            if (symbol-> data)
                free_upload ((UPLOADFILE *)symbol-> data);
          }
        usym_delete_table (m_files);
        m_files = NULL;
      }
    m_nb_file = 0;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "data">
        <type  value = "activex_cpp_data">
    VARIANT
        size,
        result;
    long
        total_bytes = 0;
    char
        *data = NULL;
    long
        codepage = CP_ACP;
    UCODE
        *ext;
    USYMBOL
        *next,
        *symbol;
        </type>
        <type  value = "activex_cpp">

    if (m_page_started)
      {
        free_tables ();
        memset (&size,   0, sizeof (VARIANT));
        memset (&result, 0, sizeof (VARIANT));
        m_request-> get_TotalBytes (&total_bytes);
        size.vt = VT_I4;
        size.lVal = total_bytes;
        m_request-> BinaryRead (&size, &result);
        if (result.vt != VT_ERROR
        &&  result.vt != VT_NULL
        &&  result.vt != VT_EMPTY
        &&  (result.vt & 0xF000) == VT_ARRAY)
          {
            data = (char *)result.parray-> pvData;
            m_session-> get_CodePage (&codepage);
            m_nb_file = http_multipart_umem ((byte *)data, total_bytes, &m_form, &m_files, codepage);
            if (m_nb_file == 0
            &&  m_files)
              {
                usym_delete_table (m_files);
                m_files = NULL;
              }
            /* Check allowed or denied file lise                             */
            else if (m_allowed_file || m_denied_file)
              {
                for (symbol = m_files-&gt; symbols; symbol; )
                  {
                    ext = wcsrchr (symbol-&gt; name, (UCODE)'.');
                    if (ext)
                      {
                        ext++;
                        if (  (   m_allowed_file
                               && usym_lookup_symbol (m_allowed_file, ext) == NULL)
                            ||(   m_denied_file
                               && usym_lookup_symbol (m_denied_file,  ext) != NULL))
                          {
                             if (symbol-&gt; data)
                                 free_upload ((UPLOADFILE *)symbol-&gt; data);
                             next = symbol-&gt; next;
                             usym_delete_symbol (m_files, symbol);
                             symbol = next;
                             m_nb_file--;
                          }
                        else
                            symbol = symbol-&gt; next;
                      }
                  }
                if (m_nb_file == 0
                &&  m_files)
                  {
                    usym_delete_table (m_files);
                    m_files = NULL;
                  }
              }
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_file_count">
        <type  value = "activex_cpp">
    *pVal = m_nb_file;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "set_crypt">
        <type  value = "activex_cpp_data">
    char
        *crypt_str;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    VARIANT2STRING (type, crypt_str);

    if (crypt_str == NULL)
        RETURN_AND_RELEASE (S_OK);

    if (lexcmp (crypt_str, "DES") == 0)
        m_crypt_type = CRYPT_TYPE_DES;
    else
    if (lexcmp (crypt_str, "3DES") == 0)
        m_crypt_type = CRYPT_TYPE_3DES;
    else
    if (lexcmp (crypt_str, "IDEA") == 0)
        m_crypt_type = CRYPT_TYPE_IDEA;
    else
        m_crypt_type = CRYPT_TYPE_RC4;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "on_start_page" threadsafe = "1" use_cpp_object = "1">
        <type  value = "activex_cpp_data">
    CComPtr&lt;IGetContextProperties&gt;
        properties;
    CComBSTR
        request;
    CComVariant
        variant;
    IDispatch
        *dispatch;
    HRESULT
        hr;
        </type>
        <type  value = "activex_cpp">

    if (m_have_context == FALSE)
        hr = ::GetObjectContext (&m_spObjectContext);
    else
        hr = S_OK;
    if (SUCCEEDED (hr))
      {
        hr = m_spObjectContext-&gt; QueryInterface (IID_IGetContextProperties, (void **)&properties);
        if (SUCCEEDED (hr))
          {
            request = "Response";
            hr = properties-&gt; GetProperty (request, &variant);
            if (SUCCEEDED (hr))
              {
                if (V_VT(&variant) == VT_DISPATCH)
                  {
                    dispatch = V_DISPATCH (&variant);
                    if (dispatch != NULL)
                      {
                        hr = dispatch-&gt; QueryInterface (IID_IResponse, (void **)&m_response);
                        if (FAILED (hr))
                            return (hr);
                      }
                  }
              }
            request = "Request";
            hr = properties-&gt; GetProperty (request, &variant);
            if (SUCCEEDED (hr))
              {
                if (V_VT(&variant) == VT_DISPATCH)
                  {
                    dispatch = V_DISPATCH (&variant);
                    if (dispatch != NULL)
                      {
                        hr = dispatch-&gt; QueryInterface (IID_IRequest, (void **)&m_request);
                        if (FAILED (hr))
                          {
                            m_response.Release ();
                            return (hr);
                          }
                      }
                  }
              }
            request = "Server";
            hr = properties-&gt; GetProperty (request, &variant);
            if (SUCCEEDED (hr))
              {
                if (V_VT(&variant) == VT_DISPATCH)
                  {
                    dispatch = V_DISPATCH (&variant);
                    if (dispatch != NULL)
                      {
                        hr = dispatch-&gt; QueryInterface (IID_IServer, (void **)&m_server);
                        if (FAILED (hr))
                          {
                            m_response.Release ();
                            m_request.Release  ();
                            return (hr);
                          }
                      }
                  }
              }

            request = "Session";
            hr = properties-&gt; GetProperty (request, &variant);
            if (SUCCEEDED (hr))
              {
                if (V_VT(&variant) == VT_DISPATCH)
                  {
                    dispatch = V_DISPATCH (&variant);
                    if (dispatch != NULL)
                      {
                        hr = dispatch-&gt; QueryInterface (IID_ISessionObject, (void **)&m_session);
                        if (FAILED (hr))
                          {
                            m_response.Release ();
                            m_request.Release  ();
                            m_server.Release   ();
                            return (hr);
                          }
                      }
                  }
              }
          }
        else
            return (hr);
      }
    else
        return (hr);

    m_page_started = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "dump">
        <type  value = "activex_cpp_data">
    UFILE
        *file;
    char
        *fname;
    USYMBOL
        *symbol;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    fname = OLE2T (file_name);
    file = unicode_open (fname, 'w');
    if (file)
      {
        if (m_form)
          {
            for (symbol = m_form-> symbols; symbol; symbol = symbol-> next)
                unicode_fprintf (file, L"%-30s: %s\n", symbol-> name, symbol-> value);
          }
        unicode_close (file);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "on_end_page">
        <type  value = "activex_cpp">
    // Release all interfaces
    m_request.Release  ();
    m_response.Release ();
    m_server.Release   ();
    m_session.Release  ();
    m_page_started = FALSE;
    free_tables ();
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    free_tables ();

    if (m_allowed_file)
      {
        usym_delete_table (m_allowed_file);
        m_allowed_file = NULL;
      }
    if (m_denied_file)
      {
        usym_delete_table (m_denied_file);
        m_denied_file = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_form">
        <type  value = "activex_cpp_data">
    UCODE    
        *value,
        *field;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    VARIANT2BSTR (field_name, field);

    if (m_form && field)
      {
        value = usym_get_value (m_form, ustrlwc (field), NULL);
        if (value != NULL)
            *pVal = SysAllocString (value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "save">
        <type  value = "activex_cpp_data">
    char
         buffer [255],
        *tmp_file,
        *end,
        *ext,
        *str_output_dir,
        *str_field_value,
        *str_file_name,
        *str_key;
    UCODE
        *field_value,
        *str_field_name;
    BSTR
        path;
    USYMBOL
        *symbol;
    FILE
        *file;
    UPLOADFILE
        *upload;
    static qbyte
        temp = 0;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = NULL;

    VARIANT2BSTR (field_name, str_field_name);
    VARIANT2STRING (output_dir, str_output_dir);
    VARIANT2STRING (file_name,  str_file_name);
    VARIANT2STRING (key,        str_key);

    if (m_form == NULL)
        RETURN_AND_RELEASE (S_OK);
    if (m_files == NULL)
        RETURN_AND_RELEASE (S_OK);
    if (str_field_name == NULL)
        RETURN_AND_RELEASE (S_FALSE);

    field_value = usym_get_value (m_form, ustrlwc (str_field_name), NULL);
    if (field_value)
      {
        symbol = usym_lookup_symbol (m_files, field_value);
        if (symbol
        &&  symbol-&gt; data)
          {
            buffer [0];
            /* Get the The temp directory if no directory specified          */
            if ( str_output_dir == NULL
            ||  *str_output_dir == 0)
              {
                str_output_dir = env_get_string  ("TEMP", NULL);
                if (!str_output_dir)
                   str_output_dir = env_get_string  ("TMP", NULL);
                if (!str_output_dir)
                    str_output_dir = ".";
                strcpy (buffer, str_output_dir);
              }
            else
              {
                /* Not a full Full path                                      */
                if (!(str_output_dir [0] == '\\'   || str_output_dir [0] == '/' ||
                   (isalpha (str_output_dir [0]) && str_output_dir [1] == ':' &&
                   (str_output_dir [2] == '\\'   || str_output_dir [2] == '/'))))
                  {
                    /* Get URL and map to full path name                     */
                    m_server-&gt; MapPath (T2BSTR ("."), &path);
                    if (path)
                        xstrcpy (buffer, OLE2T (path), "\\", str_output_dir, NULL);
                  }
                else
                    strcpy (buffer, str_output_dir);
              }

            if ( str_file_name == NULL
            ||  *str_file_name == 0)
              {
                str_field_value = ucode2ascii (field_value);
                if (str_field_value)
                  {
                    ext = strrchr (str_field_value, '.');
                    if (ext)
                        ext++;
                    if (temp == 0)
                      {
                        randomize ();
                        temp = random (0xFFFFFFFF);
                      }
                    temp++;
                    tmp_file = get_tmp_file_name (buffer, &temp, ext);
                    strcpy (buffer, tmp_file);
                    mem_free (tmp_file);
                    mem_free (str_field_value);
                  }
              }
            else
              {
                end = &buffer [strlen (buffer) - 1];
                if (*end != '/' && *end != '\\')
                    xstrcat (buffer, "\\", str_file_name, NULL);
                else
                    strcat  (buffer, str_file_name);
              }

            upload = (UPLOADFILE *)symbol-&gt; data;
            if ( str_key
            &&  *str_key)
              {
                if (buffer_encrypt (upload-&gt; data, upload-&gt; size,
                                    buffer, (byte *)str_key, strlen (str_key),
                                    m_crypt_type) == TRUE)
                  {
                    strconvch (buffer, '/', '\\');
                    *pVal = T2BSTR (strip_file_path (buffer));
                  }
              }
            else
              {
                file = fopen (buffer, "wb");
                if (file)
                  {
                    fwrite (upload-&gt; data, 1, upload-&gt; size, file);
                    fclose (file);
                    strconvch (buffer, '/', '\\');
                    *pVal = T2BSTR (strip_file_path (buffer));
                  }
              }
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "download">
        <type  value = "activex_cpp_data">
    VARIANT
        send;
    BSTR
        bstr_url  = NULL,
        path = NULL;
    char
        *mime_type,
        fname [255];
    long
        size;
    FILE
        *file;
    SAFEARRAY
        *array = NULL;
    SAFEARRAYBOUND
        dim [1];
    char
        *str_end,
        *str_dir,
        *str_fname,
        *str_key,
        buffer [255];

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (m_page_started)
      {
        VARIANT2STRING (file_name, str_fname);
        VARIANT2STRING (directory, str_dir);
        VARIANT2STRING (key,       str_key);
        if (str_fname)
          {
            fname [0] = 0;
            if (str_dir)
              {
                /* Full path                                                 */
                if (str_dir [0] == '\\'   || str_dir [0] == '/' ||
                   (isalpha (str_dir [0]) && str_dir [1] == ':' &&
                   (str_dir [2] == '\\'   || str_dir [2] == '/')))
                  {
                    strcpy (fname, str_dir);
                    str_end =  &fname [strlen (fname) - 1];
                    if (*str_end != '/'
                    &&  *str_end != '\\')
                      {
                        *(++str_end) = '\\';
                        *(++str_end) = '\0';
                      }
                  }
              }
            if (*fname == '\0')
              {
                /* Get URL and map to full path name                         */
                m_server-&gt; MapPath (T2BSTR ("."), &path);
                if (path)
                    strcpy (fname, OLE2T (path));
                if (str_dir)
                    xstrcat (fname, "\\", str_dir, "\\", str_fname, NULL);
                else
                    xstrcat (fname, "\\", str_fname, NULL);
              }
            else
                xstrcat (fname, "\\", str_fname, NULL);

            /* If securised file                                             */
            if (str_key
            &&  *str_key)
              {
                file = fopen (fname, "rb");
                if (file)
                  {
                    fread (&size, sizeof (long), 1 , file);
                    fclose (file);
                    dim [0].lLbound   = 0;
                    dim [0].cElements = size;
                    array = SafeArrayCreate (VT_UI1, 1, dim);
                    if (array
                    &&  array-&gt; pvData)
                      {
                        buffer_decrypt ((byte *)array-&gt; pvData, &size, fname,
                                        (byte *)str_key,
                                        strlen (str_key), m_crypt_type);
                      }
                  }
              }
            else
              {
                file = fopen (fname, "rb");
                if (file)
                  {
                    fseek (file, 0, SEEK_END);
                    size = ftell (file);
                    fseek (file, 0, SEEK_SET);
                    if (size > 0)
                      {
                        dim [0].lLbound   = 0;
                        dim [0].cElements = size;
                        array = SafeArrayCreate (VT_UI1, 1, dim);
                        if (array
                        &&  array-> pvData)
                            fread (array-> pvData, 1, size, file);
                      }
                    fclose (file);
                  }
              }
            if (array)
              {
                send.vt = VT_ARRAY | VT_UI1;
                send.parray = array;
                str_end = strrchr (fname, '.');
                if (str_end)
                  {
                    mime_type = get_mime_type (++str_end);
                    if (mime_type == NULL)
                        mime_type = "application/octet-stream";
                  }
                else
                    mime_type = "application/octet-stream";
//                m_response-&gt; put_ContentType (T2BSTR ("application/x-msdownload"));
                m_response-&gt; put_ContentType (T2BSTR (mime_type));
                sprintf (buffer, "attachment;filename=%s", strip_file_path (fname));
                m_response-&gt; AddHeader (T2BSTR ("Content-Disposition"), T2BSTR (buffer));
                sprintf (buffer, "%ld", size);
                m_response-&gt; AddHeader (T2BSTR ("Content-Length"), T2BSTR (buffer));
                m_response-&gt; BinaryWrite (send);
                SafeArrayDestroy (array);
              }
          }
      }
    else
        RETURN_AND_RELEASE (S_FALSE);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "allowed_list">
        <type  value = "activex_cpp_data">
    char
        *item,
        *str_files;
    UCODE
        *key;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    VARIANT2STRING (file_list, str_files);

    if (m_allowed_file)
      {
        usym_delete_table (m_allowed_file);
        m_allowed_file = NULL;
      }

    if (str_files && *str_files)
      {
        m_allowed_file = usym_create_table ();
        strlwc (str_files);
        item = strtok (str_files, ",");
        while (item)
          {
            key = ascii2ucode (trim (item));
            if (key)
              {
                usym_assume_symbol (m_allowed_file, key, L"");
                mem_free (key);
              }
            item = strtok (NULL, ",");
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "denied_list">
        <type  value = "activex_cpp_data">
    char
        *item,
        *str_files;
    UCODE
        *key;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    VARIANT2STRING (file_list, str_files);

    if (m_denied_file)
      {
        usym_delete_table (m_denied_file);
        m_denied_file = NULL;
      }

    if (str_files && *str_files)
      {
        m_denied_file = usym_create_table ();
        strlwc (str_files);
        item = strtok (str_files, ",");
        while (item)
          {
            key = ascii2ucode (trim (item));
            if (key)
              {
                usym_assume_symbol (m_denied_file, key, L"");
                mem_free (key);
              }
            item = strtok (NULL, ",");
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "save2text">
        <type  value = "activex_cpp_data">
    FILE
        *file;
    char
        *fname;
    char
        *ascii_content;
    long
        codepage;
    UCODE
        *target,
        *buffer;
    int
        buffer_size;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    fname = OLE2T (file_name);
    m_session-&gt; get_CodePage (&codepage);

    buffer_size = wcslen (content) + 1;

    target = content;
    buffer = content;
    http_decode_umeta (target, &buffer, buffer_size);

    ascii_content = ucode2ascii_ex (target, codepage);
    if (ascii_content)
      {
        file = fopen (fname, "wb");
        if (file)
          {
            fwrite (ascii_content, 1, strlen (ascii_content), file);
            fclose (file);
          }
        mem_free (ascii_content);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
</object>
<test>
&lt;%
 Set obj = Server.CreateObject ("scl.upload")
 set obj = nothing
%&gt;
</test>
<!--------------------------------------------------------------------------->
</component>

<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->
<!--------------------------------------------------------------------------->

<component
    name        = "scl_string"
    uuid        = "B97DF8A2-C99F-11D3-B3AF-00E09872C5B9"
    version     = "1.1"
    description = "Standard Component Library"
    object_name = "string">
<object
    name       = "string"
    uuid       = "8766AFD1-AEF8-F2D4-AFBA-47A941A2DAFC"
    class_uuid = "8766AFD2-AEF8-F2D4-AFBA-47A941A2DAFC">
    <description>High level string function</description>
    <property name = "match">
        <parameter type = "VARIANT"    name = "string1"  />
        <parameter type = "VARIANT"    name = "string2"  />
        <return type = "int" />
        <description>Calculates a similarity index for the two strings.  This
        is a value from 0 to 32767 with higher values indicating a closer match.
        The two strings are compared without regard for case.  The algorithm was
         designed by Leif Svalgaard</description>
        <rule name = "get_match"/>
    </property>
    <property name = "compare">
        <parameter type = "VARIANT"    name = "string"  />
        <parameter type = "VARIANT"    name = "pattern"  />
        <return type = "int" />
        <description>Compares two strings ignoring case, and allowing wildcards
        in the second string (the pattern).  Two special characters are
        recognised in the pattern: '?' matches any character in the string,
        and '*' matches the remainder of the string.
        Returns a value that is:
        &lt;PRE&gt;
        &lt;  0    if string is less than    pattern
        == 0    if string is equal to     pattern
        &gt;  0    if string is greater than pattern
        &lt;/PRE&gt;
        </description>
        <rule name = "get_compare"/>
    </property>
    <property name = "replace">
        <parameter type = "VARIANT"    name = "text"  />
        <parameter type = "VARIANT"    name = "find_text"  />
        <parameter type = "VARIANT"    name = "replace_text"  />
        <return type = "BSTR" />
        <description>Find a string into a text a replace this with a other string
        </description>
        <sample>
        Set obj = Server.CreateObject ("sstk.string")
        text = "line1" & chr (13) & "line2" & chr (13) & "line3" & chr (13)
        Response.Write obj.replace (text, chr (13), "BR")
        </sample>
        <rule name = "get_replace"/>
    </property>
    <property name = "mask">
        <parameter type = "BSTR" name = "value"  />
        <parameter type = "BSTR" name = "mask"   />
        <return type = "long" />
        <description>Validate a text value with a format.
        The format acceptable characters is:
           '9' for numeric    digit
           'X' for alphabetic digit
           '?' Any characters
           '*' Don't evalue after
        If you want match the character '9' or 'X', escape this with character '\\'.
        This property return 0 if value match mask or return the position value
        of character don't match mask
        </description>
        <sample>
        feedback = string.mask (value, "??99.99 XXX*")
        </sample>
        <rule name = "get_mask"/>
    </property>
    <property name = "htmlencode">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Translates special characters into HTML/SGML metacharacters.
        </description>
        <sample>
        feedback = string.htmlencode ("le franais, en t")
        </sample>
        <rule name = "get_htmlencode"/>
    </property>
    <property name = "htmldecode">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Translates HTML/SGML metacharacters into special characters.
        </description>
        <sample>
        feedback = string.htmldecode ("&amp;amp;lt;td&amp;amp;gt;")l
        </sample>
        <rule name = "get_htmldecode"/>
    </property>
    <property name = "soundex">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Compute the soundex code of value</description>
        <sample>
        code = string.soundex ("MacDonalds")
        </sample>
        <rule name = "get_soundex"/>
    </property>
    <property name = "encode_base64">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Encode a string into base64</description>
        <sample>
        code = string.encode_base64 ("string to scrypt")
        </sample>
        <rule name = "get_encode_base64"/>
    </property>
    <property name = "decode_base64">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Decode a string into base64</description>
        <sample>
        code = string.decode_base64 ("AaEso450rZd=")
        </sample>
        <rule name = "get_decode_base64"/>
    </property>
    <property name = "encode_utf8">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Encode a unicode string into UTF-8 format</description>
        <sample>
        code = string.encode_utf8 ("string to transform")
        </sample>
        <rule name = "get_encode_utf8"/>
    </property>
    <property name = "decode_utf8">
        <parameter type = "BSTR" name = "value"  />
        <return type = "BSTR" />
        <description>Decode a unicode string in UTF-8 format</description>
        <sample>
        code = string.decode_utf8 ("string to transform")
        </sample>
        <rule name = "get_decode_utf8"/>
    </property>
<!--------------------------------------------------------------------------->
    <rule name = "get_match">
        <type  value = "activex_cpp_data">
    char
        *str_string1,
        *str_string2;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = 0;

    VARIANT2STRING (string1, str_string1);
    VARIANT2STRING (string2, str_string2);

    if (str_string1 && str_string2)
        *pVal = strmatch (str_string1, str_string2);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_compare">
        <type  value = "activex_cpp_data">
    BSTR
        str_string,
        str_pattern;
        </type>
        <type  value = "activex_cpp">

    VARIANT2BSTR (string,  str_string);
    VARIANT2BSTR (pattern, str_pattern);

    if (str_string && str_pattern)
        *pVal = lexuwcmp (str_string, str_pattern);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_replace">
        <type  value = "activex_cpp_data">
    UCODE
        *str_text,
        *str_find,
        *str_replace,
        *str,
        *str_result  = NULL;
    int
        buffer_size,
        len_find,
        len_replace,
        replace_count;
        </type>
        <type  value = "activex_cpp">

    *pVal = NULL;

    VARIANT2BSTR (text,         str_text);
    VARIANT2BSTR (find_text,    str_find);
    VARIANT2BSTR (replace_text, str_replace);

    if (str_text
    &&  str_find
    &&  str_replace)
      {
        len_find = wcslen (str_find);
        len_replace = wcslen (str_replace);

        /* If replace string is greater than find string, calculate the      *
         * size of the result buffer                                         */
        if (len_replace > len_find)
          {
            replace_count = 0;
            str           = str_text;
            FOREVER
              {
                str = wcsstr (str, str_find);
                if (str)
                  {
                    replace_count++;
                    str += len_find;
                    if (*str == 0)
                        break;
                  }
                else
                    break;
              }

            if (replace_count == 0)
              {
                *pVal = SysAllocString (str_text);
                RETURN_AND_RELEASE (S_OK);
              }
            else
              {
                buffer_size = wcslen (str_text) + (replace_count *
                                                   (len_replace - len_find));
                str_result = unicode_alloc (buffer_size + 1);
                if (str_result)
                    wcscpy (str_result, str_text);
              }
          }
        else
            str_result = mem_ustrdup (str_text);

        if (str_result)
          {
            usearchreplace (str_result, str_find, str_replace);
            *pVal = SysAllocString (str_result);
            mem_free (str_result);
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_mask">
        <type  value = "activex_cpp_data">
    dbyte
        *value_pos,
        *mask_pos;
    Bool
        have_escape = FALSE;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    value_pos = (dbyte *)value;
    mask_pos  = (dbyte *)mask;

    while (*mask_pos)
      {
        if (*mask_pos == (dbyte)'9' && have_escape == FALSE)
          {
            if (!(*value_pos &gt;= (dbyte)'0'
            &&  *value_pos &lt;= (dbyte)'9'))
              {
                *pVal = (long)(value_pos - (dbyte *)value) + 1;
                break;
              }
          }
        else
        if (*mask_pos == (dbyte)'X' && have_escape == FALSE)
          {
            if (!(    (*value_pos &gt;= (dbyte)'a'
                   &&  *value_pos &lt;= (dbyte)'z')
                  ||  (*value_pos &gt;= (dbyte)'A'
                   &&  *value_pos &lt;= (dbyte)'Z')))
              {
                *pVal = (long)(value_pos - (dbyte *)value) + 1;
                break;
              }
          }
        else
        if (*mask_pos == (dbyte)'?' && have_escape == FALSE)
          {
          }
        else
        if (*mask_pos == (dbyte)'*' && have_escape == FALSE)
            break;
        else
        if (*mask_pos == (dbyte)'\\' && have_escape == FALSE)
          {
            have_escape = TRUE;
            value_pos--;
          }
        else
        if (*mask_pos != *value_pos)
          {
            *pVal = (long)(value_pos - (dbyte *)value) + 1;
            break;
          }
        else
        if (have_escape == TRUE)
            have_escape = FALSE;

        value_pos++;
        mask_pos++;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_htmlencode">
        <type  value = "activex_cpp_data">
    UCODE
        *buffer;
    int
        buffer_size;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);

    buffer_size = wcslen (value) + 1;
    buffer_size *= 8;                   /* One value can take &amp;#65500;   */

    buffer = unicode_alloc (buffer_size);
    if (buffer)
      {
        if (http_encode_umeta (buffer, &value, buffer_size, FALSE) > 0)
            *pVal = SysAllocString (buffer);
        mem_free (buffer);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_htmldecode">
        <type  value = "activex_cpp_data">
    UCODE
        *target,
        *buffer;
    int
        buffer_size;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);

    buffer_size = wcslen (value) + 1;

    target = value;
    buffer = value;
        if (http_decode_umeta (target, &buffer, buffer_size) > 0)
            *pVal = SysAllocString (target);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_soundex">
        <type  value = "activex_cpp_data">
    UCODE
        *buffer;
    char
        *code,
        *string;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);

    string = ucode2ascii (value);
    if (string)
      {
        code   = soundex (string);
        buffer = ascii2ucode (code);
        if (buffer)
          {
            *pVal = SysAllocString (buffer);
            mem_free (buffer);
          }
        mem_free (string);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_encode_base64">
        <type  value = "activex_cpp_data">
    char
        *encoded,
        *char_value;
    int
        size,
        target_size;
    UCODE
        *buffer;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);
    
    char_value = ucode2ascii (value);
    if (char_value)
      {
        size        = strlen (char_value);
        target_size = (int)((double)size * 1.5);
        encoded     = (char *)mem_alloc (target_size + 1);
        if (encoded)
          {
            encode_base64 (char_value, encoded, size);
            buffer = ascii2ucode (encoded);
            if (buffer)
              {
                *pVal = SysAllocString (buffer);
                mem_free (buffer);
              }
            mem_free (encoded);
          }
        mem_free (char_value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_decode_base64">
        <type  value = "activex_cpp_data">
    char
        *encoded,
        *char_value;
    int
        size;
    UCODE
        *buffer;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);
    
    char_value = ucode2ascii (value);
    if (char_value)
      {
        size = strlen (char_value);
        encoded = (char *)mem_alloc (size + 1);
        if (encoded)
          {
            decode_base64 (char_value, encoded, size);
            buffer = ascii2ucode (encoded);
            if (buffer)
              {
                *pVal = SysAllocString (buffer);
                mem_free (buffer);
              }
            mem_free (encoded);
          }
        mem_free (char_value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_encode_utf8">
        <type  value = "activex_cpp_data">
    char
        *char_value;
    UCODE
        *buffer;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);

    char_value = ucode2utf8 (value);
    if (char_value)
      {
        buffer = ascii2ucode (char_value);
        if (buffer)
          {
            *pVal = SysAllocString (buffer);
            mem_free (buffer);
          }
        mem_free (char_value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_decode_utf8">
        <type  value = "activex_cpp_data">
    char
        *char_value;
    UCODE
        *buffer;
        </type>
        <type  value = "activex_cpp">
    *pVal = 0;

    if (value == NULL || *value == NULL)
        RETURN_AND_RELEASE (S_OK);

    char_value = ucode2ascii (value);
    if (char_value)
      {
        buffer = utf82ucode (char_value);       
        if (buffer)
          {
            *pVal = SysAllocString (buffer);
            mem_free (buffer);
          }
        mem_free (char_value);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_split_search">
        <type  value = "activex_cpp_data">
    SAFEARRAY
        *array = NULL;
    SAFEARRAYBOUND
        dim [4];
    LIST
        list;
    SEARCH_TOKEN
        *token;
    char
        *buffer;
    long
        index,
        token_count;
    VARIANT
        variant [4];
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    pVal-&gt; vt = VT_NULL;

    if (value     == NULL 
    || *value     == NULL)
        RETURN_AND_RELEASE (S_OK);


    buffer = ucode2ascii (value);
    if (buffer)
      {
        list_reset (&list);
        token_count = search_split (buffer, &list, search_mode);
        mem_strfree (&buffer);
      }

    if (token_count &gt; 0)
      {
        dim [0].cElements = token_count;
        dim [0].lLbound   = 0;
        dim [1].cElements = token_count;
        dim [1].lLbound   = 0;
        dim [2].cElements = token_count;
        dim [2].lLbound   = 0;
        dim [3].cElements = token_count;
        dim [3].lLbound   = 0;

        array = SafeArrayCreate (VT_VARIANT, 4, dim);
        if (array
        &&  array-&gt; pvData)
          {
            token = (SEARCH_TOKEN *)list.next;
            for (index = 0; index &lt; token_count; index++)
              {
                variant [0].vt      = VT_BSTR;
                variant [0].bstrVal = T2BSTR (token-&gt; value);
                variant [1].vt      = VT_I2;
                variant [1].iVal    = token-&gt; type;
                variant [2].vt      = VT_I2;
                variant [2].iVal    = token-&gt; operation;
                variant [3].vt      = VT_I2;
                variant [3].iVal    = token-&gt; query;
                SafeArrayPutElement (array, &index, variant);
                token = token-&gt; next;
              }
            pVal-&gt; vt     = VT_ARRAY|VT_VARIANT;
            pVal-&gt; parray = array; 
          }
        free_token_list (&list);
      } 
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2BSTR(var, str) {                                             \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = dest.bstrVal;                                              \
      }                                                                      \
}
        </type>
    </rule>
<!--------------------------------------------------------------------------->
</object>
<test>
&lt;%
 Set obj = Server.CreateObject ("scl.string")
 set obj = nothing
%&gt;
</test>
<!--------------------------------------------------------------------------->
</component>
<component
    name        = "scl_directory"
    uuid        = "B9EDF8A0-C99F-11D3-B3AF-00E0A87EC5BF"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "directory">
<object
    name       = "directory"
    uuid       = "8766AFB0-AEF8-F2DF-AFBA-49A941AEDAFC"
    class_uuid = "8766AFB1-AEF8-F2DF-AFBA-49A941AEDAFC">
    <description>High level directory function</description>
    <attribute name = "main_node"   type = "NODE"     reference = "yes" />
    <attribute name = "fileinfo"    type = "FILEINFO" reference = "yes" />
    <attribute name = "valid"       type = "bool"/>

    <method name = "open">
        <parameter type = "VARIANT"    name = "path"  />
        <parameter type = "VARIANT"    name = "sort"  optional="1"/>
        <description>    Loads and sorts the contents of a directory.
    Return the fist file name.
    You can ask for the directory list to be sorted in various
    ways; in this case subdirectory entries are always sorted first.  To
    specify the sort order you pass a string consisting of one or more of
    these characters, which are then used in order:
    n      Sort by ascending name.
    N      Sort by descending name.
    x      Sort by ascending extension.
    X      Sort by descending extension.
    t      Sort by ascending time and date.
    T      Sort by descending time and date.
    s      Sort by ascending size.
    S      Sort by descending size.
        </description>
        <rule name = "get_open"/>
    </method>
    <method name = "filter">
        <parameter type = "VARIANT"    name = "mask"  />
        <description>
        Filter directory listing with a file mask (like DOS).
        Return the number of file in the list.
        </description>
        <rule name = "get_filter"/>
    </method>
    <property name = "file_name">
        <return type = "BSTR" />
        <description>Return the current file name</description>
        <rule name = "get_file_name"/>
    </property>
    <property name = "file_date">
        <return type = "long" />
        <description>Return the current file date in format yyyymmdd</description>
        <rule name = "get_file_date"/>
    </property>
    <property name = "file_time">
        <return type = "long" />
        <description>Return the current file time in format hhmmsscc</description>
        <rule name = "get_file_time"/>
    </property>
    <property name = "file_size">
        <return type = "double" />
        <description>Return the current file size</description>
        <rule name = "get_file_size"/>
    </property>
    <property name = "is_directory">
        <return type = "BOOL" />
        <description>Return TRUE if the current file is a sub directory</description>
        <rule name = "get_is_directory"/>
    </property>
    <method name = "next">
        <description>Move to the next file in directory.
        </description>
        <rule name = "get_next"/>
    </method>
    <method name = "previous">
        <description>Move to the previous file in directory.
        </description>
        <rule name = "get_previous"/>
    </method>
    <method name = "first">
        <description>Move to the first file in directory.
        </description>
        <rule name = "get_first"/>
    </method>
    <method name = "last">
        <description>Move to the last file in directory.
        </description>
        <rule name = "get_last"/>
    </method>
    <property name = "valid">
        <return type = "BOOL" />
        <description>Indicates if last executed method was valid</description>
        <rule name = "get_valid"/>
        <sample>If dir.valid Then
                End If</sample>
    </property>
    <method name = "close">
        <description>Close current directory listing</description>
        <rule name = "close"/>
    </method>
    <property name = "move">
        <parameter type = "VARIANT"    name = "source"     />
        <parameter type = "VARIANT"    name = "destination"/>
        <return type = "BOOL" />
        <description>Move a file to another destination</description>
        <rule name = "get_move"/>
    </property>
    <property name = "delete">
        <parameter type = "VARIANT"    name = "file_name" />
        <return type = "BOOL" />
        <description>Delete a file</description>
        <rule name = "get_delete"/>
    </property>
<!--------------------------------------------------------------------------->
<!-- Rules implementation                                                  -->
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_main_node)
      {
        free_dir_list (m_main_node);
        m_main_node = NULL;
      }
    m_fileinfo = NULL;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2BSTR(var, str) {                                             \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = dest.bstrVal;                                              \
      }                                                                      \
}
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_open">
        <type  value = "activex_cpp_data">
    char
        *char_path,
        *char_sort;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    VARIANT2STRING (path, char_path);
    VARIANT2STRING (sort, char_sort);

    if (m_main_node)
      {
        free_dir_list (m_main_node);
        m_main_node = NULL;
      }
    m_fileinfo = NULL;
    m_valid = FALSE;

    if (char_sort == NULL)
        char_sort = "nx";

    m_main_node = load_dir_list (char_path, char_sort);

    if (m_main_node)
      {
        m_fileinfo = (FILEINFO *)m_main_node-> next;
        if ((void *)m_fileinfo != (void *)m_main_node)
          {
            m_valid = TRUE;
          }
        else
            m_fileinfo = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_filter">
        <type  value = "activex_cpp_data">
    FILEINFO
        *current,
        *next;
    char
        *char_mask;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;
    VARIANT2STRING (mask, char_mask);
    if (m_main_node)
      {
        current = (FILEINFO *)m_main_node-> next;
        while ((void *)current != (void *)m_main_node)
          {
            next = current-> next;
            if (!file_matches (current-> dir.file_name, char_mask))
              {
                free_dir (&current-> dir);
                node_destroy (current);
              }
            current = next;
          }
        m_fileinfo = (FILEINFO *)m_main_node-> next;
        if ((void *)m_fileinfo != (void *)m_main_node)
            m_valid = TRUE;
        else
            m_fileinfo = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_file_name">
        <type  value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    if (m_fileinfo && m_fileinfo-> dir.file_name)
      {
        *pVal = T2BSTR (m_fileinfo-> dir.file_name);
      }
    else
        *pVal = NULL;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_file_date">
        <type  value = "activex_cpp">
    if (m_fileinfo)
        *pVal = timer_to_date (m_fileinfo-> dir.file_time);
    else
        *pVal = 0;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_file_time">
        <type  value = "activex_cpp">
    if (m_fileinfo)
        *pVal = timer_to_time (m_fileinfo-> dir.file_time);
    else
        *pVal = 0;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_file_size">
        <type  value = "activex_cpp">
    if (m_fileinfo)
        *pVal = m_fileinfo-> dir.file_size;
    else
        *pVal = 0;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_is_directory">
        <type  value = "activex_cpp">
    if (m_fileinfo)
        *pVal = m_fileinfo-> directory;
    else
        *pVal = FALSE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_next">
        <type  value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_fileinfo)
      {
        m_fileinfo = m_fileinfo-> next;
        if ((void *)m_fileinfo != (void *)m_main_node)
          {
            m_valid = TRUE;
          }
        else
            m_fileinfo = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_first">
        <type  value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_main_node)
      {
        m_fileinfo = (FILEINFO *)m_main_node-> next;
        if ((void *)m_fileinfo != (void *)m_main_node)
          {
            m_valid = TRUE;
          }
        else
            m_fileinfo = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_last">
        <type  value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    if (m_main_node)
      {
        m_fileinfo = (FILEINFO *)m_main_node-> prev;
        if ((void *)m_fileinfo != (void *)m_main_node)
          {
            m_valid = TRUE;
          }
        else
            m_fileinfo = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_previous">
        <type  value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_fileinfo)
      {
        m_fileinfo = m_fileinfo-> prev;
        if ((void *)m_fileinfo != (void *)m_main_node)
          {
            m_valid = TRUE;
          }
        else
            m_fileinfo = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_valid">
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = m_valid;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "close">
        <type  value = "activex_cpp">
    if (m_main_node)
      {
        free_dir_list (m_main_node);
        m_main_node = NULL;
      }
    m_fileinfo = NULL;
    m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_move">
        <type  value = "activex_cpp_data">
    char
        *char_source,
        *char_destination;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    *pVal   = FALSE;
    m_valid = FALSE;

    VARIANT2STRING (source,      char_source);
    VARIANT2STRING (destination, char_destination);

    if (char_source
    &&  char_destination
    &&  file_exists (char_source))
      {
        if (file_exists (char_destination))
            file_delete (char_destination);
        if (file_copy (char_source, char_destination, 'b') == 0)
          {
            if (file_delete (char_source) >= 0)
              {
                m_valid = TRUE;
                *pVal   = TRUE;
              }
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_delete">
        <type  value = "activex_cpp_data">
    char
        *filename;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    *pVal   = FALSE;
    m_valid = FALSE;

    VARIANT2STRING (file_name, filename);
    if (filename && file_exists (filename))
      {
        if (file_delete (filename) >= 0)
          {
            *pVal    = TRUE;
             m_valid = TRUE;
          }
      }
        </type>
    </rule>
</object>
<test>
&lt;table&gt;
&lt;%
 Set obj = Server.CreateObject ("scl.directory")
 obj.open "c:\", "Nx"
 obj.filter "*.bat"
 do while (obj.valid)
    if obj.is_directory then
        response.write "&lt;tr&gt;&lt;td&gt;"
        response.write "&lt;B&gt;" & obj.file_name & "&lt;/B&gt;"
        response.write "&lt;/td&gt;&lt;/tr&gt;"
    else
    response.write "&lt;tr&gt;&lt;td&gt;"
    response.write "&lt;B&gt;" & obj.file_name & "&lt;/B&gt;"
    response.write "&lt;/td&gt;&lt;td&gt;" & obj.file_size & "Bytes"
    response.write "&lt;/td&gt;&lt;td&gt;" & obj.file_date
    response.write "&lt;/td&gt;&lt;td&gt;" & obj.file_size
    response.write "&lt;/td&gt;&lt;/tr&gt;"
    end if
    obj.next
 loop
  obj.close
  Set Obj = Nothing
%&gt;
&lt;/table&gt;
</test>
</component>
<!--------------------------------------------------------------------------->
<component
    name        = "scl_translation"
    uuid        = "B9EDF8A0-C99F-11D3-B3AF-00E0A87EC9BF"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "translation">
<used_library name = "libtran" />
<object
    name       = "translation"
    uuid       = "8766AFB0-AEF8-F2DF-AFBA-49A941AEDAA9"
    class_uuid = "8766AFB1-AEF8-F2DF-AFBA-49A941AEDAA9">
    <description>Component to help translation of application</description>
    <attribute name = "dict"           type = "DICT_CTX"  reference = "yes" />
    <attribute name = "cur_screen"     type = "SYMBOL"    reference = "yes" />
    <attribute name = "cur_value"      type = "SYMBOL"    reference = "yes" />
    <attribute name = "cur_usage"      type = "SYMBOL"    reference = "yes" />
    <attribute name = "usage_fieldid"  type = "long"/>
    <attribute name = "usage_screenid" type = "long"/>
    <attribute name = "valid"          type = "bool"/>

    <method name = "open">
        <parameter type = "VARIANT"    name = "name"  />
        <description>Loads a translation dictionary in memory.</description>
        <rule name = "get_open_dictionary"/>
    </method>
    <method name = "save">
        <parameter type = "VARIANT"    name = "name"  />
        <description>Save translation dictionary in memory to a file.</description>
        <rule name = "get_save_dictionary"/>
    </method>
    <method name = "create">
        <description>Create a new translation dictionary in memory.</description>
        <rule name = "get_new_dictionary"/>
    </method>
    <method name = "first_screen">
        <description>Go to first screen in dictionary.</description>
        <rule name = "get_first_screen"/>
    </method>
    <method name = "next_screen">
        <description>Go to next screen in dictionary.</description>
        <rule name = "get_next_screen"/>
    </method>
    <method name = "previous_screen">
        <description>Go to previous screen in dictionary.</description>
        <rule name = "get_previous_screen"/>
    </method>
    <method name = "last_screen">
        <description>Go to last screen in dictionary.</description>
        <rule name = "get_screen_screen"/>
    </method>
    <property name = "screen_name">
        <parameter type = "VARIANT"    name = "id" optional = "1" />
        <return type = "BSTR" />
        <description>Get the current screen name if screen id is not used</description>
        <rule name = "get_screen_name"/>
    </property>
    <property name = "screen_id">
        <parameter type = "VARIANT"    name = "name" optional = "1" />
        <return type = "long" />
        <description>Get the current screen id if screen name is not used</description>
        <rule name = "get_screen_id"/>
    </property>
    <property name = "screen_external_id">
        <return type = "long" />
        <description>Get the current screen external id if screen name is not used</description>
        <rule name = "get_screen_ext_id"/>
    </property>
    <property name = "screen_external_id">
        <parameter name = "external_id" type = "long" />
        <description>Set the current screen external id</description>
        <rule name = "put_screen_ext_id"/>
    </property>
    <property name = "valid">
        <return type = "BOOL" />
        <description>Indicates if last executed method was valid</description>
        <rule name = "get_valid"/>
        <sample>If obj.valid Then
                End If</sample>
    </property>
    <method name = "first_term">
        <description>Go to first term in dictionary.</description>
        <rule name = "get_first_term"/>
    </method>
    <method name = "next_term">
        <description>Go to next term in dictionary.</description>
        <rule name = "get_next_term"/>
    </method>
    <method name = "previous_term">
        <description>Go to previous screen in dictionary.</description>
        <rule name = "get_previous_term"/>
    </method>
    <method name = "last_term">
        <description>Go to last term in dictionary.</description>
        <rule name = "get_last_term"/>
    </method>
    <property name = "term_value">
        <parameter type = "VARIANT"    name = "id"       optional = "1" />
        <parameter type = "VARIANT"    name = "language" optional = "1" />
        <return type = "BSTR" />
        <description>Get the current term value if term id is not used</description>
        <rule name = "get_term_name"/>
    </property>
    <property name = "term_id">
        <parameter type = "VARIANT"    name = "value"    optional = "1" />
        <return type = "long" />
        <description>Get the current term id if term value is not used</description>
        <rule name = "get_term_id"/>
    </property>
    <property name = "term_language">
        <return type = "BSTR" />
        <description>Get the current language value</description>
        <rule name = "get_term_language"/>
    </property>
    <property name = "term_external_id">
        <return type = "long" />
        <description>Get the current term external id</description>
        <rule name = "get_term_ext_id"/>
    </property>
    <property name = "term_external_id">
        <parameter name = "external_id" type = "long" />
        <description>Set the current term external id</description>
        <rule name = "put_term_ext_id"/>
    </property>
    <property name = "term_technical">
        <return type = "BOOL" />
        <description>Return TRUE if term is a technical term</description>
        <rule name = "get_term_technical"/>
    </property>
    <property name = "term_type">
        <return type = "long" />
        <description>Return the term type:
         0: Normal term
         1: Term have translation by screen in dictionary
         2: translation of term only in one screen
        </description>
        <rule name = "get_term_type"/>
    </property>
    <property name = "first_usage">
        <parameter type = "long"    name = "term_id"/>
        <return type = "long" />
        <description>Go to first usage in dictionary for this term id.
        Return the screen id
        </description>
        <rule name = "get_first_usage"/>
    </property>
    <property name = "next_usage">
        <return type = "long" />
        <description>Go to next usage in dictionary for this term id.
        Return the screen id
        </description>
        <rule name = "get_next_usage"/>
    </property>
    <property name = "usage_external_id">
        <return type = "long" />
        <description>Go to usage external id from current usage.</description>
        <rule name = "get_usage_ext_id"/>
    </property>
    <property name = "add_term">
        <parameter name = "language"    type = "BSTR" />
        <parameter name = "value"       type = "BSTR" />
        <parameter name = "external_id" type = "VARIANT" optional = "1"/>
        <parameter name = "id"          type = "VARIANT" optional = "1"/>
        <parameter name = "technical"   type = "VARIANT" optional = "1"/>
        <parameter name = "type"        type = "VARIANT" optional = "1"/>
        <parameter name = "screen"      type = "VARIANT" optional = "1"/>
        <return type = "long"/>
        <description>Create a new term into translation dictionary.
        Technical indicate a technical term. Type canhave 3 values:
         0: Normal term
         1: Term have translation by screen in dictionary
         2: translation of term only in one screen

         Screen parameter is the screen name when type = 2. If screen is
         NULL and type = 2, try to find the screen name in dictionary
        </description>
        <rule name = "add_term"/>
    </property>
    <method name = "add_usage">
        <parameter name = "termid"      type = "long"    />
        <parameter name = "screen"      type = "VARIANT" />
        <parameter name = "external_id" type = "VARIANT" optional = "1"/>
        <description>Create a new usage into translation dictionary</description>
        <rule name = "add_usage"/>
    </method>
    <property name = "add_screen">
        <parameter name = "name"        type = "VARIANT" />
        <parameter name = "external_id" type = "VARIANT" optional = "1"/>
        <return type = "long"/>
        <description>Create a new screen into translation dictionary</description>
        <rule name = "add_screen"/>
    </property>
<!--------------------------------------------------------------------------->
<!-- Rules implementation                                                  -->
<!--------------------------------------------------------------------------->
    <!--rule name = "constructor">
        <type  value = "activex_cpp">

        </type>
    </rule-->
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_dict)
      {
        free_dictionary (m_dict);
        m_dict = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_library">
        <type  value = "activex_cpp">
#include "markdict.h"
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = OLE2T (dest.bstrVal);                                      \
      }                                                                      \
}

#define VARIANT2BSTR(var, str) {                                             \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = dest.bstrVal;                                              \
      }                                                                      \
}

#define VARIANT2LONG(var, str) {                                             \
    VARIANT dest;                                                            \
    str = 0L;                                                                \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \
            str = dest.lVal;                                                 \
      }                                                                      \
}

#define TERM_MULTI_VALUE  1
#define TERM_UNIQUE_VALUE 2

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_open_dictionary">
        <type  value = "activex_cpp_data">
    char
        *char_name;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">

    m_valid = FALSE;

    VARIANT2STRING (name, char_name);

    if (char_name && file_exists (char_name))
      {
        m_dict = load_bin_dictionary (char_name);
        if (m_dict)
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_save_dictionary">
        <type  value = "activex_cpp_data">
    char
        *char_name;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;

    VARIANT2STRING (name, char_name);

    if (char_name && m_dict)
      {
        save_bin_dictionary (char_name, m_dict);
        m_valid = TRUE;
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_new_dictionary">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    m_dict = load_bin_dictionary ("");
    if (m_dict)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_first_screen">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    m_cur_screen = m_dict-> screen-> symbols;
    if (m_cur_screen)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_next_screen">
        <type  value = "activex_cpp">
    m_valid = FALSE;
 
    if (m_cur_screen == NULL)
        m_cur_screen = m_dict-> screen-> symbols;
    else
        m_cur_screen = m_cur_screen-> next;
    if (m_cur_screen)
        m_valid = TRUE;

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_previous_screen">
        <type  value = "activex_cpp">
    m_valid = FALSE;
 
    if (m_cur_screen)
        m_cur_screen = m_cur_screen-> prev;
    if (m_cur_screen)
        m_valid = TRUE;

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_last_screen">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    for (m_cur_screen = m_dict-> screen-> symbols;
         m_cur_screen && m_cur_screen-> next;
         m_cur_screen = m_cur_screen-> next);

    if (m_cur_screen)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_screen_name">
        <type  value = "activex_cpp_data">
    char
        *screen_name;
    long
        screen_id;
    char
        key_buffer [20];

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = NULL;

    VARIANT2LONG (id, screen_id);

    if (screen_id > 0 && m_dict)
       {
         sprintf (key_buffer, "%ld", screen_id);
         m_cur_screen = sym_lookup_symbol (m_dict-> screen_id, key_buffer);
       }
    if (m_cur_screen && m_cur_screen-> data)
      {
        screen_name = ((SCREEN *)m_cur_screen-> data)-> value;
        if (screen_name)
          {
            *pVal = T2BSTR (screen_name);
            m_valid = TRUE;
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_screen_id">
        <type  value = "activex_cpp_data">
    char
        *screen_name;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = 0;

    VARIANT2STRING (name, screen_name);

    if (screen_name && m_dict)
        m_cur_screen = sym_lookup_symbol (m_dict-> screen, screen_name);

    if (m_cur_screen && m_cur_screen-> data)
      {
        *pVal = ((SCREEN *)m_cur_screen-> data)-> id;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_screen_ext_id">
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = 0;

    if (m_cur_screen && m_cur_screen-> data)
      {
        *pVal = ((SCREEN *)m_cur_screen-> data)-> ext_id;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_screen_ext_id">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_cur_screen && m_cur_screen-> data)
      {
        ((SCREEN *)m_cur_screen-> data)-> ext_id = external_id;
        m_valid = TRUE;
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_valid">
        <type  value = "activex_cpp">
    if (pVal == NULL)
        RETURN_AND_RELEASE (S_OK);

    *pVal = m_valid;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_first_term">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    m_cur_value = m_dict-> translated-> symbols;
    if (m_cur_value)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_next_term">
        <type  value = "activex_cpp">
    m_valid = FALSE;
 
    if (m_cur_value == NULL)
        m_cur_value = m_dict-> translated-> symbols;
    else
        m_cur_value = m_cur_value-> next;
    if (m_cur_value)
        m_valid = TRUE;

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_previous_term">
        <type  value = "activex_cpp">
    m_valid = FALSE;
 
    if (m_cur_value)
        m_cur_value = m_cur_value-> prev;
    if (m_cur_value)
        m_valid = TRUE;

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_last_term">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    for (m_cur_value = m_dict-> translated-> symbols;
         m_cur_value && m_cur_value-> next;
         m_cur_value = m_cur_value-> next);

    if (m_cur_value)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_term_name">
        <type  value = "activex_cpp_data">
    long
        term_id;
    char
        key_buffer [20];
    LANG_VALUE
        *val;
    UCODE
        *old,
        *in;

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = NULL;

    VARIANT2LONG (id, term_id);

    if (term_id > 0 && m_dict)
       {
         sprintf (key_buffer, "%ld", term_id);
         m_cur_value = sym_lookup_symbol (m_dict-> translated, key_buffer);
       }
    if (m_cur_value && m_cur_value-> data)
      {
        val = (LANG_VALUE *)m_cur_value-> data;
        if (val-> is_unicode)
          {
            in = ascii2ucode (val-> value);
            old = in;
            if (http_decode_umeta (old, &in, wcslen (in) + 1) > 0)
                *pVal = SysAllocString (old);
            if (old)
                mem_free (old);
          }
        else
          {
            *pVal = T2BSTR (val-> value);
            m_valid = TRUE;
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_term_language">
        <type  value = "activex_cpp_data">
    char
        *term_language;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = NULL;

    if (m_cur_value && m_cur_value-> data)
      {
        term_language = ((LANG_VALUE *)m_cur_value-> data)-> language;
        if (term_language)
          {
            *pVal = T2BSTR (term_language);
            m_valid = TRUE;
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_term_id">
        <type  value = "activex_cpp_data">
    char
        *term_value;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = 0;

    VARIANT2STRING (value, term_value);

    if (term_value && m_dict)
        m_cur_value = sym_lookup_symbol (m_dict-> def_value, term_value);

    if (m_cur_value && m_cur_value-> data)
      {
        *pVal = ((LANG_VALUE *)m_cur_value-> data)-> field_id;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_term_ext_id">
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = 0;

    if (m_cur_value && m_cur_value-> data)
      {
        *pVal = ((LANG_VALUE *)m_cur_value-> data)-> ext_id;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_term_technical">
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = FALSE;

    if (m_cur_value && m_cur_value-> data)
      {
        *pVal = ((LANG_VALUE *)m_cur_value-> data)-> is_technical;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_term_type">
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal = 0;

    if (m_cur_value && m_cur_value-> data)
      {
        if (((LANG_VALUE *)m_cur_value-> data)-> multi_value)
            *pVal = TERM_MULTI_VALUE;
        else
        if (((LANG_VALUE *)m_cur_value-> data)-> unique_value)
            *pVal = TERM_UNIQUE_VALUE;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "put_screen_ext_id">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_cur_value && m_cur_value-> data)
      {
        ((SCREEN *)m_cur_value-> data)-> ext_id = external_id;
        m_valid = TRUE;
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_first_usage">
        <type  value = "activex_cpp_data">
    char
        key_buffer [20];
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal   = 0;
    
    m_cur_usage = NULL;
    m_usage_fieldid = term_id;

    for (m_usage_screenid = 1; m_usage_screenid &lt;= m_dict-&gt; max_screenid;
         m_usage_screenid++)
      {
        sprintf (key_buffer, "%ld_%ld", m_usage_fieldid, m_usage_screenid);     
        m_cur_usage = sym_lookup_symbol (m_dict-&gt; usage, key_buffer);
        if (m_cur_usage && m_cur_usage-&gt;data)
          {
            *pVal = ((USAGE *)m_cur_usage-&gt;data)-> screen_id;
            break;
          }
      }
    if (*pVal)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_next_usage">
        <type  value = "activex_cpp_data">
    char
        key_buffer [20];
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal   = 0;  
    m_cur_usage = NULL;

    for (++m_usage_screenid; m_usage_screenid &lt;= m_dict-&gt; max_screenid;
         m_usage_screenid++)
      {
        sprintf (key_buffer, "%ld_%ld", m_usage_fieldid, m_usage_screenid);     
        m_cur_usage = sym_lookup_symbol (m_dict-&gt; usage, key_buffer);
        if (m_cur_usage && m_cur_usage-&gt;data)
          {
            *pVal = ((USAGE *)m_cur_usage-&gt;data)-> screen_id;
            break;
          }
      }
    if (*pVal)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_usage_ext_id">
        <type  value = "activex_cpp">
    m_valid = FALSE;
    *pVal   = 0;  

    if (m_cur_usage && m_cur_usage-&gt; data)
      {
        *pVal = ((USAGE *)(m_cur_usage-&gt; data))-> ext_id;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "add_term">
        <type  value = "activex_cpp_data">
    char
        *screen_name,
        *char_language;
    long
        is_technical,
        term_type,
        new_id,
        ext_id;
    Bool
        multi_val  = FALSE,
        unique_val = FALSE;

    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;

    char_language = OLE2T (language);
    VARIANT2LONG   (external_id, ext_id);
    VARIANT2LONG   (id,          new_id);
    VARIANT2LONG   (technical,   is_technical);
    VARIANT2LONG   (type,        term_type);
    VARIANT2STRING (screen,      screen_name);

    if (term_type == TERM_MULTI_VALUE)
        multi_val = TRUE;
    else
    if (term_type == TERM_UNIQUE_VALUE)
        unique_val = TRUE;

    *pVal = add_dictionary_item_ext (value, char_language, ext_id,
                                    (Bool)is_technical,
                                     multi_val, unique_val, new_id,
                                     screen_name, m_dict);
    if (*pVal > 0)
        m_valid = TRUE;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "add_usage">
        <type  value = "activex_cpp_data">
    char
        *screen_name;
    long
        ext_id;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    VARIANT2STRING (screen, screen_name);
    VARIANT2LONG   (external_id, ext_id);

    update_usage (screen_name, termid, ext_id, m_dict);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "add_screen">
        <type  value = "activex_cpp_data">
    char
        *screen_name;
    long
        ext_id;
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    VARIANT2STRING (name, screen_name);
    VARIANT2LONG   (external_id, ext_id);

    *pVal = update_screen (screen_name, ext_id, m_dict);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
</object>
<test>
&lt;table&gt;
&lt;%
 Set obj = Server.CreateObject ("scl.translation")
 Set Obj = Nothing
%&gt;
&lt;/table&gt;
</test>
</component>
<!--------------------------------------------------------------------------->
<component
    name        = "scl_bits"
    uuid        = "B9EDF8A0-CAAF-11D3-B3AF-00EFA87EC9BF"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "bits">
<object
    name       = "bits"
    uuid       = "876FAFB0-AEF8-F2DF-AFBA-49AC41AEDAA9"
    class_uuid = "876FAFB1-AEF8-F2DF-AFBA-49AC41AEDAA9">
    <description>Component to manipulate bitstring</description>
    <attribute name = "bits"           type = "BITS"   reference = "yes" />
    <attribute name = "last_pos"       type = "long"                     />

    <method name = "create">
        <parameter type = "VARIANT"    name = "value"    optional = "1" />
        <description>Create a new bitstring. Load from value if value is not empty</description>
        <rule name = "bit_create"/>
    </method>
    <method name = "set">
        <parameter type = "long"    name = "value"  />
        <description>Set to 1 the bit in position stored in value.</description>
        <rule name = "bit_set"/>
    </method>
    <method name = "reset">
        <parameter type = "long"    name = "value"  />
        <description>Set to 0 the bit in position stored in value.</description>
        <rule name = "bit_reset"/>
    </method>
    <method name = "and">
        <parameter type = "BSTR"    name = "value"  />
        <description>Execute a logical AND between current bitstring and
        'value' bitstring. To get the result, use 'save' method</description>
        <rule name = "bit_and"/>
    </method>
    <method name = "or">
        <parameter type = "BSTR"    name = "value"  />
        <description>Execute a logical OR between current bitstring and
        'value' bitstring. To get the result, use 'save' method</description>
        <rule name = "bit_or"/>
    </method>
    <method name = "xor">
        <parameter type = "BSTR"    name = "value"  />
        <description>Execute a logical XOR between current bitstring and
        'value' bitstring. To get the result, use 'save' method</description>
        <rule name = "bit_xor"/>
    </method>
    <method name = "invert">
        <description>Invert current value of bitstring</description>
        <rule name = "bit_invert"/>
    </method>
    <property name = "save">
        <return type = "BSTR"/>
        <description>Save current bitstring into a string</description>
        <rule name = "get_save"/>
    </property>
    <property name = "search_set">
        <parameter type = "VARIANT"    name = "reverse" optional = "1" />
        <parameter type = "VARIANT"    name = "from"    optional = "1" />
        <return type = "long"/>
        <description>Return the next bit set to 1. Search from the last
        returned value. You can specify the 'from' value for the search.
        if reverse is set to TRUE, search to the beginning
         </description>
        <rule name = "get_search_set"/>
    </property>
    <property name = "count">
        <return type = "long"/>
        <description>Return the count of bit set to 1</description>
        <rule name = "get_count"/>
    </property>
<!--------------------------------------------------------------------------->
<!-- Rules implementation                                                  -->
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    if (m_bits)
      {
        bits_destroy (m_bits);
        m_bits = NULL;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = ucode2ascii (dest.bstrVal);                                \
      }                                                                      \
}

#define VARIANT2LONG(var, str) {                                             \
    VARIANT dest;                                                            \
    str = -1L;                                                               \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \
            str = dest.lVal;                                                 \
      }                                                                      \
}

/* Get a Boolean from a variant value                                       */
#define VARIANT2BOOL(var, str) {                                             \
    VARIANT dest;                                                            \
    str = FALSE;                                                             \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BOOL) == S_OK)           \
            str = (BOOL)dest.boolVal;                                        \
      }                                                                      \
}
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_create">
        <type  value = "activex_cpp_data">
    char
        *buffer;
        </type>
        <type  value = "activex_cpp">
    VARIANT2STRING (value, buffer);
    if (m_bits)
      {
        bits_destroy (m_bits);
        m_bits = NULL;
      }
    if (buffer)
      {
        m_bits = bits_load (buffer);
        mem_free (buffer);
      }
    else
        m_bits = bits_create ();

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_set">
        <type  value = "activex_cpp">
    if (m_bits)
        bits_set (m_bits, value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_reset">
        <type  value = "activex_cpp">
    if (m_bits)
        bits_clear (m_bits, value);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_and">
        <type  value = "activex_cpp_data">
    char
        *string;
    BITS
        *result,
        *bits;
        </type>
        <type  value = "activex_cpp">
    string = ucode2ascii (value);

    if (string)
      {
        bits = bits_load (string);
        if (bits)
          {
            result = bits_and (m_bits, bits);
            if (result)
              {
                bits_destroy (m_bits);
                m_bits = result;
                m_last_pos = 0;
              }
            bits_destroy (bits);
          }
        mem_free (string);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_or">
        <type  value = "activex_cpp_data">
    char
        *string;
    BITS
        *result,
        *bits;
        </type>
        <type  value = "activex_cpp">
    string = ucode2ascii (value);

    if (string)
      {
        bits = bits_load (string);
        if (bits)
          {
            result = bits_or (m_bits, bits);
            if (result)
              {
                bits_destroy (m_bits);
                m_bits = result;
                m_last_pos = 0;
              }
            bits_destroy (bits);
          }
        mem_free (string);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_xor">
        <type  value = "activex_cpp_data">
    char
        *string;
    BITS
        *result,
        *bits;
        </type>
        <type  value = "activex_cpp">
    string = ucode2ascii (value);

    if (string)
      {
        bits = bits_load (string);
        if (bits)
          {
            result = bits_xor (m_bits, bits);
            if (result)
              {
                bits_destroy (m_bits);
                m_bits = result;
                m_last_pos = 0;
              }
            bits_destroy (bits);
          }
        mem_free (string);
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "bit_invert">
        <type  value = "activex_cpp_data">
    BITS
        *result;
        </type>
        <type  value = "activex_cpp">
    result = bits_invert (m_bits);
    if (result)
      {
        bits_destroy (m_bits);
        m_bits = result;
        m_last_pos = 0;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_save">
        <type  value = "activex_cpp_data">
    char
        *buffer = NULL;
    UCODE
        *ubuffer;
        </type>
        <type  value = "activex_cpp">

    *pVal = NULL;

    if (m_bits)
      {
        buffer = bits_save (m_bits);
        if (buffer)
          {
            ubuffer = ascii2ucode (buffer);
            mem_free (buffer);
            *pVal = SysAllocString (ubuffer);
            mem_free (ubuffer);
          }
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_search_set">
        <type  value = "activex_cpp_data">
    long
        from_value;
    Bool
        reverse_value;
        </type>
        <type  value = "activex_cpp">
    if (m_bits)
      {
        VARIANT2LONG (from,    from_value);
        VARIANT2BOOL (reverse, reverse_value);

        if (from_value >= 0)
            m_last_pos = from_value;
        if (reverse_value && m_last_pos == 0)
            m_last_pos = BIT_MAXBITS - 1;
        *pVal = bits_search_set (m_bits, m_last_pos, (Bool)reverse_value);
        if (*pVal >= 0)
            m_last_pos = *pVal;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_count">
        <type  value = "activex_cpp">
    *pVal = 0;

    if (m_bits)
        *pVal = bits_set_count (m_bits);
        </type>
    </rule>
</object>
<test>
&lt;h1&gt;Test Bits Library (SCL)&lt;/h1&gt;
&lt;table border="2"&gt;
&lt;tr&gt;&lt;th&gt;&lt;b&gt;Value in bitstring 1&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Value in bitstring 2&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;5&lt;/td&gt;&lt;td align=right&gt;6&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;123&lt;/td&gt;&lt;td align=right&gt;123&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;568&lt;/td&gt;&lt;td align=right&gt;5689&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;45312&lt;/td&gt;&lt;td align=right&gt;45312&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;102789&lt;/td&gt;&lt;td align=right&gt;102789&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;452123&lt;/td&gt;&lt;td align=right&gt;185548&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;756321&lt;/td&gt;&lt;td align=right&gt;452123&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;1256208&lt;/td&gt;&lt;td align=right&gt;1256208&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;1285548&lt;/td&gt;&lt;td align=right&gt;7568321&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td align=right&gt;9853415&lt;/td&gt;&lt;td align=right&gt;9853415&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;%
sub set_bits1
    bits1.create
    bits1.set 5
    bits1.set 123
    bits1.set 568
    bits1.set 45312
    bits1.set 102789
    bits1.set 452123
    bits1.set 756321
    bits1.set 1256208
    bits1.set 1285548
    bits1.set 9853415
end sub

sub set_bits2
    bits2.create
    bits2.set 6
    bits2.set 123
    bits2.set 5689
    bits2.set 45312
    bits2.set 102789
    bits2.set 185548
    bits2.set 452123
    bits2.set 1256208
    bits2.set 7568321
    bits2.set 9853415
end sub

sub display_value (title)
 Response.Write "&lt;table border=""2""&gt;&lt;tr&gt;&lt;th&gt;&lt;b&gt;" & title & "(" & _
                bits1.count & ")&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;"
 value = 0
 Do While (value &gt;= 0)
     value = bits1.search_set
     if value &gt; 0 then
         Response.Write "&lt;tr&gt;&lt;td align=right&gt;" & value & "&lt;/td&gt;&lt;/tr&gt;"
     end if
 Loop
 Response.write "&lt;/table&gt;"
end sub

 Set bits1 = Server.CreateObject ("scl.bits")
 Set bits2 = Server.CreateObject ("scl.bits")
 set_bits1
 set_bits2

 bits2_value = bits2.save

 bits1.and CStr (bits2_value)
 display_value "Result of AND"

 set_bits1
 bits1.or CStr (bits2_value)
 display_value "Result of OR"

 set_bits1
 bits1.xor CStr (bits2_value)
 display_value "Result of XOR"

 Set bits1 = Nothing
 Set bits2 = Nothing
%&gt;
</test>
</component>
<!--------------------------------------------------------------------------->
<component
    name        = "scl_search"
    uuid        = "B9EDF8A0-CFAF-99D3-B3EF-00EFA87EC9BF"
    version     = "1.0"
    description = "Standard Component Library"
    object_name = "search">
<additional_source file = "..\..\iafsearch\sflsearch.c" />
<object
    name       = "search"
    uuid       = "876FAFB0-FFF8-22DF-AEBA-29AC41AEDFF9"
    class_uuid = "876FAFB1-FFF8-22DF-AEBA-29AC41AEDFF9">
    <description>Component for search functionality</description>
    <attribute name = "list"    type = "LIST" noinit    = "1"  />
    <attribute name = "token"   type = "void" reference = "yes"/>
    <attribute name = "count"   type = "long"                  />
    <attribute name = "valid"   type = "BOOL"                  />

    <method name = "split">
        <parameter type = "VARIANT"    name = "value"/>
        <parameter type = "VARIANT"    name = "search_mode" optional = "1"/>
        <description>Split a string into search token. By default search mode is TRUE</description>
        <rule name = "get_split_search"/>
    </method>
    <method name = "first">
        <description>Go to the first search token</description>
        <rule name = "search_first"/>
    </method>
    <method name = "last">
        <description>Go to the last search token</description>
        <rule name = "search_last"/>
    </method>
    <method name = "next">
        <description>Go to the next search token</description>
        <rule name = "search_next"/>
    </method>
    <method name = "previous">
        <description>Go to the previous search token</description>
        <rule name = "search_previous"/>
    </method>
    <property name = "count">
        <return type = "long"/>
        <description>Return the number of token</description>
        <rule name = "get_count"/>
    </property>
    <property name = "keyword">
        <return type = "BSTR"/>
        <description>Return the search keyword value.
         </description>
        <rule name = "get_keyword"/>
    </property>
    <property name = "type">
        <return type = "long"/>
        <description>
        Return the search keyword type.
        1   SOUNDEX keyword
        2   PREFIX  keyword (2 characters)
        3   NUMERIC keyword
         </description>
        <rule name = "get_type"/>
    </property>
    <property name = "operation">
        <return type = "long"/>
        <description>
        Return the search keyword operation.
        1   OR
        2   AND
        3   AND NOT
        4   SECOND RANGE VALUE
         </description>
        <rule name = "get_operation"/>
    </property>
    <property name = "query">
        <return type = "long"/>
        <description>
        Return the search keyword query.
        1 EQUAL
        2 GREATER EQUAL
        3 LESS EQUAL
        4 RANGE
         </description>
        <rule name = "get_query"/>
    </property>
    <property name = "valid">
        <return type = "BOOL"/>
        <description>Return TRUE if last action is valid</description>
        <rule name = "get_valid"/>
    </property>
<!--------------------------------------------------------------------------->
<!-- Rules implementation                                                  -->
<!--------------------------------------------------------------------------->
    <rule name = "destructor">
        <type  value = "activex_cpp">
    free_token_list (&m_list);    
    list_reset (&m_list);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "constructor">
        <type  value = "activex_cpp">
    list_reset (&m_list);
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "include_definition">
        <type  value = "activex_cpp">
#include "..\..\iafsearch\sflsearch.h"

/* Get a char * from a variant value                                         */
#define VARIANT2STRING(var, str) {                                           \
    VARIANT dest;                                                            \
    str = NULL;                                                              \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \
            str = ucode2ascii (dest.bstrVal);                                \
      }                                                                      \
}

#define VARIANT2LONG(var, str) {                                             \
    VARIANT dest;                                                            \
    str = -1L;                                                               \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \
            str = dest.lVal;                                                 \
      }                                                                      \
}

/* Get a Boolean from a variant value                                       */
#define VARIANT2BOOL(var, str) {                                             \
    VARIANT dest;                                                            \
    str = TRUE;                                                             \
    if (var.vt != VT_ERROR                                                   \
    &&  var.vt != VT_EMPTY                                                   \
    &&  var.vt != VT_NULL)                                                   \
      {                                                                      \
        memset (&dest, 0, sizeof (VARIANT));                                 \
        if (::VariantChangeType (&dest, &var, 0, VT_BOOL) == S_OK)           \
            str = (BOOL)dest.boolVal;                                        \
      }                                                                      \
}

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_split_search">
        <type  value = "activex_cpp_data">
    BOOL
        b_search_mode;
    char
        *buffer;
        </type>
        <type  value = "activex_cpp">

    free_token_list (&m_list);
    list_reset      (&m_list);
    m_token = NULL;
    m_count = 0;
    m_valid = FALSE;

    VARIANT2STRING (value, buffer);
    VARIANT2BOOL   (search_mode, b_search_mode);

    if (buffer)
      {
        list_reset (&m_list);
        m_count = search_split (buffer, &m_list, b_search_mode);
        mem_strfree (&buffer);
      }

    if (m_count &gt; 0)
      {
        m_token = (SEARCH_TOKEN *)m_list.next;
        m_valid = TRUE;
      }

        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "search_first">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_count &gt; 0)
      {
        m_token = (void *)m_list.next;  
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "search_last">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_count &gt; 0)
      {
        m_token = (void *)m_list.prev;  
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "search_next">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_token && m_count &gt; 0)
      {
        m_token = ((SEARCH_TOKEN *)m_token)-&gt; next;  
        if (m_token == (void *)&m_list)
            m_token = ((SEARCH_TOKEN *)m_token)-&gt; prev;
        else
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "search_previous">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_token && m_count &gt; 0)
      {
        m_token = ((SEARCH_TOKEN *)m_token)-&gt; prev;  
        if ((void *)m_token == (void *)&m_list)
            m_token = ((SEARCH_TOKEN *)m_token)-&gt; next;
        else
            m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_count">
        <type  value = "activex_cpp">
    *pVal = m_count;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_valid">
        <type  value = "activex_cpp">
    *pVal = m_valid;
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_keyword">
        <type  value = "activex_cpp_data">
    USES_CONVERSION;
        </type>
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_token && ((SEARCH_TOKEN *)m_token)-&gt; value)
      {
        *pVal = T2BSTR (((SEARCH_TOKEN *)m_token)-&gt; value);
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_type">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_token)
      {
        *pVal = ((SEARCH_TOKEN *)m_token)-&gt; type;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_operation">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_token)
      {
        *pVal = ((SEARCH_TOKEN *)m_token)-&gt; operation;
        m_valid = TRUE;
      }
        </type>
    </rule>
<!--------------------------------------------------------------------------->
    <rule name = "get_query">
        <type  value = "activex_cpp">
    m_valid = FALSE;

    if (m_token)
      {
        *pVal = ((SEARCH_TOKEN *)m_token)-&gt; query;
        m_valid = TRUE;
      }
        </type>
    </rule>
</object>
<test>
&lt;%
  sub test_search (buffer)
Dim token
  Response.Write "&lt;hr&gt;&lt;h2&gt;Test of string '" & buffer & "'&lt;/h2&gt;"
  Response.write "&lt;table border=2&gt;&lt;tr&gt;&lt;th&gt;Token&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Operation&lt;/th&gt;&lt;th&gt;Query&lt;/th&gt;&lt;/tr&gt;"
  psearch.split buffer

  do while (psearch.valid)

      'write token value
      response.write "&lt;tr&gt;&lt;td&gt;" & psearch.keyword & "&lt;/td&gt;&lt;td&gt;"

      'write token type
      select case psearch.type
          case TOKEN_TYPE_SOUNDEX
              response.write "SOUNDEX"
          case TOKEN_TYPE_PREFIX
              response.write "PREFIX"
          case TOKEN_TYPE_NUMBER
              response.write "NUMBER"
      end select

      response.write "&lt;/td&gt;&lt;td&gt;"

      'write token operation
      select case psearch.operation
          case TOKEN_OPERATION_OR        
              response.write "OR"
          case TOKEN_OPERATION_AND       
              response.write "AND"
          case TOKEN_OPERATION_NAND      
              response.write "NAND"
          case TOKEN_OPERATION_RANGEPART 
              response.write "RANGE PART"
      end select
      response.write "&lt;/td&gt;&lt;td&gt;"

      'write token query
      select case psearch.query
          case TOKEN_QUERY_EQ            
              response.write "EQUAL"
          case TOKEN_QUERY_GE            
              response.write "GREATER"
          case TOKEN_QUERY_LE            
              response.write "LESS"
          case TOKEN_QUERY_RANGE         
              response.write "RANGE"
      end select
      response.write "&lt;/td&gt;&lt;/tr&gt;"

      psearch.next
  loop
  response.write "&lt;/table&gt;"
  end sub

  Set psearch = server.createobject ("scl.search")

  test_search "123"
  test_search "abcd f"
  test_search "abc123"
  test_search "deh 123.56 ty"
  test_search "-deh +rtf -56"
  test_search "&gt;45 rtb&gt;"
  test_search "a&gt;b 56&gt;"
  test_search "-45&gt;89 -56&gt;&gt; 89"
  test_search ""
  test_search "-&gt;rt &lt;56&gt; test@ma,rt"

  Set psearch = Nothing
%&gt;
</test>
</component>
<library
    name   = "libscl"
    target = "libscl">
</library>
